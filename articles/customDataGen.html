<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="youdrawitR">
<title>Examples: customDataGen • youdrawitR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Examples: customDataGen">
<meta property="og:description" content="youdrawitR">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">youdrawitR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Examples</h6>
    <a class="dropdown-item" href="../articles/customDataGen.html">customDataGen</a>
    <a class="dropdown-item" href="../articles/linearDataGen.html">linearDataGen</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Extra</h6>
    <a class="dropdown-item" href="../articles/web_only/ShinyApp.html">Shiny App</a>
    <a class="dropdown-item" href="../articles/customizing.html">Plot &amp; Button Guide</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/earobinson95/youdrawitR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">



<script src="customDataGen_files/htmlwidgets-1.6.2/htmlwidgets.js"></script><script src="customDataGen_files/r2d3-render-0.1.0/r2d3-render.js"></script><script src="customDataGen_files/webcomponents-2.0.0/webcomponents.js"></script><script src="customDataGen_files/r2d3-binding-0.2.6/r2d3.js"></script><script src="customDataGen_files/d3v5-5.9.2/d3.min.js"></script><script src="customDataGen_files/d3-jetpack-2.0.9/d3-jetpack.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Examples: customDataGen</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/earobinson95/youdrawitR/blob/HEAD/vignettes/customDataGen.Rmd" class="external-link"><code>vignettes/customDataGen.Rmd</code></a></small>
      <div class="d-none name"><code>customDataGen.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://earobinson95.github.io/youdrawitR/">youdrawitR</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use iris data set</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span></span></code></pre></div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p><code><a href="../reference/customDataGen.html">customDataGen()</a></code> is a versatile function that processes a
dataframe to generate data that is suitable for visualizing with the
<code><a href="../reference/drawr.html">drawr()</a></code> function. This function allows you to specify the
type of regression, the degree of polynomial or loess regression,
whether to apply a log transformation to y for the fitted line, and
whether a confidence interval should be generated.</p>
<p>In this example, we will use the iris dataset and use the
<code><a href="../reference/customDataGen.html">customDataGen()</a></code> function to process it.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Use customDataGen to process the data</span></span>
<span><span class="va">custom_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">iris</span>,</span>
<span>  xvar <span class="op">=</span> <span class="st">"Petal.Length"</span>,</span>
<span>  yvar <span class="op">=</span> <span class="st">"Petal.Width"</span>,</span>
<span>  regression_type <span class="op">=</span> <span class="st">"linear"</span>,</span>
<span>  log_y <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  conf_int <span class="op">=</span> <span class="cn">TRUE</span> <span class="co"># conf_int can only be true for linear regression</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/customDataGen.html">customDataGen()</a></code>function does not necessarily need
you to provide an xvar and yvar, if none are provided it will use the
first column as the xvar and the second column as the yvar. For
additional information on parameters of <code><a href="../reference/customDataGen.html">customDataGen()</a></code>
function look at the function documentation.</p>
<p>The <code><a href="../reference/customDataGen.html">customDataGen()</a></code> function returns a list containing
the point data and line data processed from the inputted data frame.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Print out the custom data</span></span>
<span><span class="va">custom_data</span></span>
<span><span class="co">#&gt; $line_data</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 150 × 7</span></span></span>
<span><span class="co">#&gt;    data          x      y  coef    int lower_bound upper_bound</span></span>
<span><span class="co">#&gt;    <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 1</span> line_data   1   0.052<span style="text-decoration: underline;">7</span> 0.416 -<span style="color: #BB0000;">0.363</span>    -<span style="color: #BB0000;">0.009</span><span style="color: #BB0000; text-decoration: underline;">27</span>       0.115</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 2</span> line_data   1.1 0.094<span style="text-decoration: underline;">3</span> 0.416 -<span style="color: #BB0000;">0.363</span>     0.033<span style="text-decoration: underline;">9</span>        0.155</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 3</span> line_data   1.2 0.136  0.416 -<span style="color: #BB0000;">0.363</span>     0.077<span style="text-decoration: underline;">0</span>        0.195</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 4</span> line_data   1.2 0.136  0.416 -<span style="color: #BB0000;">0.363</span>     0.077<span style="text-decoration: underline;">0</span>        0.195</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 5</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 6</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 7</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 8</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 9</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">10</span> line_data   1.3 0.177  0.416 -<span style="color: #BB0000;">0.363</span>     0.120         0.235</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># ℹ 140 more rows</span></span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $point_data</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 150 × 3</span></span></span>
<span><span class="co">#&gt;    data           x     y</span></span>
<span><span class="co">#&gt;    <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>      <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 1</span> point_data   1     0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 2</span> point_data   1.1   0.1</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 3</span> point_data   1.2   0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 4</span> point_data   1.2   0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 5</span> point_data   1.3   0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 6</span> point_data   1.3   0.4</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 7</span> point_data   1.3   0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 8</span> point_data   1.3   0.2</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 9</span> point_data   1.3   0.3</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">10</span> point_data   1.3   0.3</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># ℹ 140 more rows</span></span></span></code></pre></div>
<p>Now let’s input the data into the <code><a href="../reference/drawr.html">drawr()</a></code> function to
visualize the processed data. Additionally we can specify the axis
labels and titles of the graph, as well as produce a 95% confidence
interval since it was generated using customDataGen earlier.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data</span>, </span>
<span>      title <span class="op">=</span> <span class="st">"Petal Width vs Petal Length"</span>, </span>
<span>      x_lab <span class="op">=</span> <span class="st">"Petal Width"</span>,</span>
<span>      subtitle <span class="op">=</span> <span class="st">"Petal Length"</span>,</span>
<span>      conf_int <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-b780e317af1607e91821" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-b780e317af1607e91821">{"x":{"data":{"line_data":[{"data":"line_data","x":1,"y":0.0527,"coef":0.4158,"int":-0.3631,"lower_bound":-0.0093,"upper_bound":0.1146,"_row":1},{"data":"line_data","x":1.1,"y":0.0943,"coef":0.4158,"int":-0.3631,"lower_bound":0.0339,"upper_bound":0.1546,"_row":2},{"data":"line_data","x":1.2,"y":0.1358,"coef":0.4158,"int":-0.3631,"lower_bound":0.077,"upper_bound":0.1946,"_row":3},{"data":"line_data","x":1.2,"y":0.1358,"coef":0.4158,"int":-0.3631,"lower_bound":0.077,"upper_bound":0.1946,"_row":4},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":5},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":6},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":7},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":8},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":9},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":10},{"data":"line_data","x":1.3,"y":0.1774,"coef":0.4158,"int":-0.3631,"lower_bound":0.1202,"upper_bound":0.2346,"_row":11},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":12},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":13},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":14},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":15},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":16},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":17},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":18},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":19},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":20},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":21},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":22},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":23},{"data":"line_data","x":1.4,"y":0.219,"coef":0.4158,"int":-0.3631,"lower_bound":0.1633,"upper_bound":0.2747,"_row":24},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":25},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":26},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":27},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":28},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":29},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":30},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":31},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":32},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":33},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":34},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":35},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":36},{"data":"line_data","x":1.5,"y":0.2606,"coef":0.4158,"int":-0.3631,"lower_bound":0.2064,"upper_bound":0.3148,"_row":37},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":38},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":39},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":40},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":41},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":42},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":43},{"data":"line_data","x":1.6,"y":0.3021,"coef":0.4158,"int":-0.3631,"lower_bound":0.2494,"upper_bound":0.3549,"_row":44},{"data":"line_data","x":1.7,"y":0.3437,"coef":0.4158,"int":-0.3631,"lower_bound":0.2924,"upper_bound":0.395,"_row":45},{"data":"line_data","x":1.7,"y":0.3437,"coef":0.4158,"int":-0.3631,"lower_bound":0.2924,"upper_bound":0.395,"_row":46},{"data":"line_data","x":1.7,"y":0.3437,"coef":0.4158,"int":-0.3631,"lower_bound":0.2924,"upper_bound":0.395,"_row":47},{"data":"line_data","x":1.7,"y":0.3437,"coef":0.4158,"int":-0.3631,"lower_bound":0.2924,"upper_bound":0.395,"_row":48},{"data":"line_data","x":1.9,"y":0.4269,"coef":0.4158,"int":-0.3631,"lower_bound":0.3784,"upper_bound":0.4753,"_row":49},{"data":"line_data","x":1.9,"y":0.4269,"coef":0.4158,"int":-0.3631,"lower_bound":0.3784,"upper_bound":0.4753,"_row":50},{"data":"line_data","x":3,"y":0.8842,"coef":0.4158,"int":-0.3631,"lower_bound":0.8479,"upper_bound":0.9205,"_row":51},{"data":"line_data","x":3.3,"y":1.0089,"coef":0.4158,"int":-0.3631,"lower_bound":0.9745,"upper_bound":1.0433,"_row":52},{"data":"line_data","x":3.3,"y":1.0089,"coef":0.4158,"int":-0.3631,"lower_bound":0.9745,"upper_bound":1.0433,"_row":53},{"data":"line_data","x":3.5,"y":1.0921,"coef":0.4158,"int":-0.3631,"lower_bound":1.0584,"upper_bound":1.1257,"_row":54},{"data":"line_data","x":3.5,"y":1.0921,"coef":0.4158,"int":-0.3631,"lower_bound":1.0584,"upper_bound":1.1257,"_row":55},{"data":"line_data","x":3.6,"y":1.1336,"coef":0.4158,"int":-0.3631,"lower_bound":1.1002,"upper_bound":1.1671,"_row":56},{"data":"line_data","x":3.7,"y":1.1752,"coef":0.4158,"int":-0.3631,"lower_bound":1.1419,"upper_bound":1.2086,"_row":57},{"data":"line_data","x":3.8,"y":1.2168,"coef":0.4158,"int":-0.3631,"lower_bound":1.1835,"upper_bound":1.2501,"_row":58},{"data":"line_data","x":3.9,"y":1.2584,"coef":0.4158,"int":-0.3631,"lower_bound":1.2249,"upper_bound":1.2918,"_row":59},{"data":"line_data","x":3.9,"y":1.2584,"coef":0.4158,"int":-0.3631,"lower_bound":1.2249,"upper_bound":1.2918,"_row":60},{"data":"line_data","x":3.9,"y":1.2584,"coef":0.4158,"int":-0.3631,"lower_bound":1.2249,"upper_bound":1.2918,"_row":61},{"data":"line_data","x":4,"y":1.2999,"coef":0.4158,"int":-0.3631,"lower_bound":1.2663,"upper_bound":1.3336,"_row":62},{"data":"line_data","x":4,"y":1.2999,"coef":0.4158,"int":-0.3631,"lower_bound":1.2663,"upper_bound":1.3336,"_row":63},{"data":"line_data","x":4,"y":1.2999,"coef":0.4158,"int":-0.3631,"lower_bound":1.2663,"upper_bound":1.3336,"_row":64},{"data":"line_data","x":4,"y":1.2999,"coef":0.4158,"int":-0.3631,"lower_bound":1.2663,"upper_bound":1.3336,"_row":65},{"data":"line_data","x":4,"y":1.2999,"coef":0.4158,"int":-0.3631,"lower_bound":1.2663,"upper_bound":1.3336,"_row":66},{"data":"line_data","x":4.1,"y":1.3415,"coef":0.4158,"int":-0.3631,"lower_bound":1.3076,"upper_bound":1.3755,"_row":67},{"data":"line_data","x":4.1,"y":1.3415,"coef":0.4158,"int":-0.3631,"lower_bound":1.3076,"upper_bound":1.3755,"_row":68},{"data":"line_data","x":4.1,"y":1.3415,"coef":0.4158,"int":-0.3631,"lower_bound":1.3076,"upper_bound":1.3755,"_row":69},{"data":"line_data","x":4.2,"y":1.3831,"coef":0.4158,"int":-0.3631,"lower_bound":1.3487,"upper_bound":1.4174,"_row":70},{"data":"line_data","x":4.2,"y":1.3831,"coef":0.4158,"int":-0.3631,"lower_bound":1.3487,"upper_bound":1.4174,"_row":71},{"data":"line_data","x":4.2,"y":1.3831,"coef":0.4158,"int":-0.3631,"lower_bound":1.3487,"upper_bound":1.4174,"_row":72},{"data":"line_data","x":4.2,"y":1.3831,"coef":0.4158,"int":-0.3631,"lower_bound":1.3487,"upper_bound":1.4174,"_row":73},{"data":"line_data","x":4.3,"y":1.4247,"coef":0.4158,"int":-0.3631,"lower_bound":1.3898,"upper_bound":1.4595,"_row":74},{"data":"line_data","x":4.3,"y":1.4247,"coef":0.4158,"int":-0.3631,"lower_bound":1.3898,"upper_bound":1.4595,"_row":75},{"data":"line_data","x":4.4,"y":1.4662,"coef":0.4158,"int":-0.3631,"lower_bound":1.4308,"upper_bound":1.5017,"_row":76},{"data":"line_data","x":4.4,"y":1.4662,"coef":0.4158,"int":-0.3631,"lower_bound":1.4308,"upper_bound":1.5017,"_row":77},{"data":"line_data","x":4.4,"y":1.4662,"coef":0.4158,"int":-0.3631,"lower_bound":1.4308,"upper_bound":1.5017,"_row":78},{"data":"line_data","x":4.4,"y":1.4662,"coef":0.4158,"int":-0.3631,"lower_bound":1.4308,"upper_bound":1.5017,"_row":79},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":80},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":81},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":82},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":83},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":84},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":85},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":86},{"data":"line_data","x":4.5,"y":1.5078,"coef":0.4158,"int":-0.3631,"lower_bound":1.4717,"upper_bound":1.544,"_row":87},{"data":"line_data","x":4.6,"y":1.5494,"coef":0.4158,"int":-0.3631,"lower_bound":1.5125,"upper_bound":1.5863,"_row":88},{"data":"line_data","x":4.6,"y":1.5494,"coef":0.4158,"int":-0.3631,"lower_bound":1.5125,"upper_bound":1.5863,"_row":89},{"data":"line_data","x":4.6,"y":1.5494,"coef":0.4158,"int":-0.3631,"lower_bound":1.5125,"upper_bound":1.5863,"_row":90},{"data":"line_data","x":4.7,"y":1.591,"coef":0.4158,"int":-0.3631,"lower_bound":1.5532,"upper_bound":1.6288,"_row":91},{"data":"line_data","x":4.7,"y":1.591,"coef":0.4158,"int":-0.3631,"lower_bound":1.5532,"upper_bound":1.6288,"_row":92},{"data":"line_data","x":4.7,"y":1.591,"coef":0.4158,"int":-0.3631,"lower_bound":1.5532,"upper_bound":1.6288,"_row":93},{"data":"line_data","x":4.7,"y":1.591,"coef":0.4158,"int":-0.3631,"lower_bound":1.5532,"upper_bound":1.6288,"_row":94},{"data":"line_data","x":4.7,"y":1.591,"coef":0.4158,"int":-0.3631,"lower_bound":1.5532,"upper_bound":1.6288,"_row":95},{"data":"line_data","x":4.8,"y":1.6326,"coef":0.4158,"int":-0.3631,"lower_bound":1.5938,"upper_bound":1.6713,"_row":96},{"data":"line_data","x":4.8,"y":1.6326,"coef":0.4158,"int":-0.3631,"lower_bound":1.5938,"upper_bound":1.6713,"_row":97},{"data":"line_data","x":4.8,"y":1.6326,"coef":0.4158,"int":-0.3631,"lower_bound":1.5938,"upper_bound":1.6713,"_row":98},{"data":"line_data","x":4.8,"y":1.6326,"coef":0.4158,"int":-0.3631,"lower_bound":1.5938,"upper_bound":1.6713,"_row":99},{"data":"line_data","x":4.9,"y":1.6741,"coef":0.4158,"int":-0.3631,"lower_bound":1.6344,"upper_bound":1.7138,"_row":100},{"data":"line_data","x":4.9,"y":1.6741,"coef":0.4158,"int":-0.3631,"lower_bound":1.6344,"upper_bound":1.7138,"_row":101},{"data":"line_data","x":4.9,"y":1.6741,"coef":0.4158,"int":-0.3631,"lower_bound":1.6344,"upper_bound":1.7138,"_row":102},{"data":"line_data","x":4.9,"y":1.6741,"coef":0.4158,"int":-0.3631,"lower_bound":1.6344,"upper_bound":1.7138,"_row":103},{"data":"line_data","x":4.9,"y":1.6741,"coef":0.4158,"int":-0.3631,"lower_bound":1.6344,"upper_bound":1.7138,"_row":104},{"data":"line_data","x":5,"y":1.7157,"coef":0.4158,"int":-0.3631,"lower_bound":1.6749,"upper_bound":1.7565,"_row":105},{"data":"line_data","x":5,"y":1.7157,"coef":0.4158,"int":-0.3631,"lower_bound":1.6749,"upper_bound":1.7565,"_row":106},{"data":"line_data","x":5,"y":1.7157,"coef":0.4158,"int":-0.3631,"lower_bound":1.6749,"upper_bound":1.7565,"_row":107},{"data":"line_data","x":5,"y":1.7157,"coef":0.4158,"int":-0.3631,"lower_bound":1.6749,"upper_bound":1.7565,"_row":108},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":109},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":110},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":111},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":112},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":113},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":114},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":115},{"data":"line_data","x":5.1,"y":1.7573,"coef":0.4158,"int":-0.3631,"lower_bound":1.7154,"upper_bound":1.7992,"_row":116},{"data":"line_data","x":5.2,"y":1.7989,"coef":0.4158,"int":-0.3631,"lower_bound":1.7558,"upper_bound":1.8419,"_row":117},{"data":"line_data","x":5.2,"y":1.7989,"coef":0.4158,"int":-0.3631,"lower_bound":1.7558,"upper_bound":1.8419,"_row":118},{"data":"line_data","x":5.3,"y":1.8404,"coef":0.4158,"int":-0.3631,"lower_bound":1.7961,"upper_bound":1.8847,"_row":119},{"data":"line_data","x":5.3,"y":1.8404,"coef":0.4158,"int":-0.3631,"lower_bound":1.7961,"upper_bound":1.8847,"_row":120},{"data":"line_data","x":5.4,"y":1.882,"coef":0.4158,"int":-0.3631,"lower_bound":1.8364,"upper_bound":1.9276,"_row":121},{"data":"line_data","x":5.4,"y":1.882,"coef":0.4158,"int":-0.3631,"lower_bound":1.8364,"upper_bound":1.9276,"_row":122},{"data":"line_data","x":5.5,"y":1.9236,"coef":0.4158,"int":-0.3631,"lower_bound":1.8767,"upper_bound":1.9705,"_row":123},{"data":"line_data","x":5.5,"y":1.9236,"coef":0.4158,"int":-0.3631,"lower_bound":1.8767,"upper_bound":1.9705,"_row":124},{"data":"line_data","x":5.5,"y":1.9236,"coef":0.4158,"int":-0.3631,"lower_bound":1.8767,"upper_bound":1.9705,"_row":125},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":126},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":127},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":128},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":129},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":130},{"data":"line_data","x":5.6,"y":1.9652,"coef":0.4158,"int":-0.3631,"lower_bound":1.9169,"upper_bound":2.0134,"_row":131},{"data":"line_data","x":5.7,"y":2.0067,"coef":0.4158,"int":-0.3631,"lower_bound":1.9571,"upper_bound":2.0564,"_row":132},{"data":"line_data","x":5.7,"y":2.0067,"coef":0.4158,"int":-0.3631,"lower_bound":1.9571,"upper_bound":2.0564,"_row":133},{"data":"line_data","x":5.7,"y":2.0067,"coef":0.4158,"int":-0.3631,"lower_bound":1.9571,"upper_bound":2.0564,"_row":134},{"data":"line_data","x":5.8,"y":2.0483,"coef":0.4158,"int":-0.3631,"lower_bound":1.9973,"upper_bound":2.0993,"_row":135},{"data":"line_data","x":5.8,"y":2.0483,"coef":0.4158,"int":-0.3631,"lower_bound":1.9973,"upper_bound":2.0993,"_row":136},{"data":"line_data","x":5.8,"y":2.0483,"coef":0.4158,"int":-0.3631,"lower_bound":1.9973,"upper_bound":2.0993,"_row":137},{"data":"line_data","x":5.9,"y":2.0899,"coef":0.4158,"int":-0.3631,"lower_bound":2.0374,"upper_bound":2.1424,"_row":138},{"data":"line_data","x":5.9,"y":2.0899,"coef":0.4158,"int":-0.3631,"lower_bound":2.0374,"upper_bound":2.1424,"_row":139},{"data":"line_data","x":6,"y":2.1315,"coef":0.4158,"int":-0.3631,"lower_bound":2.0775,"upper_bound":2.1854,"_row":140},{"data":"line_data","x":6,"y":2.1315,"coef":0.4158,"int":-0.3631,"lower_bound":2.0775,"upper_bound":2.1854,"_row":141},{"data":"line_data","x":6.1,"y":2.173,"coef":0.4158,"int":-0.3631,"lower_bound":2.1176,"upper_bound":2.2285,"_row":142},{"data":"line_data","x":6.1,"y":2.173,"coef":0.4158,"int":-0.3631,"lower_bound":2.1176,"upper_bound":2.2285,"_row":143},{"data":"line_data","x":6.1,"y":2.173,"coef":0.4158,"int":-0.3631,"lower_bound":2.1176,"upper_bound":2.2285,"_row":144},{"data":"line_data","x":6.3,"y":2.2562,"coef":0.4158,"int":-0.3631,"lower_bound":2.1976,"upper_bound":2.3147,"_row":145},{"data":"line_data","x":6.4,"y":2.2978,"coef":0.4158,"int":-0.3631,"lower_bound":2.2377,"upper_bound":2.3579,"_row":146},{"data":"line_data","x":6.6,"y":2.3809,"coef":0.4158,"int":-0.3631,"lower_bound":2.3176,"upper_bound":2.4442,"_row":147},{"data":"line_data","x":6.7,"y":2.4225,"coef":0.4158,"int":-0.3631,"lower_bound":2.3576,"upper_bound":2.4874,"_row":148},{"data":"line_data","x":6.7,"y":2.4225,"coef":0.4158,"int":-0.3631,"lower_bound":2.3576,"upper_bound":2.4874,"_row":149},{"data":"line_data","x":6.9,"y":2.5056,"coef":0.4158,"int":-0.3631,"lower_bound":2.4374,"upper_bound":2.5738,"_row":150}],"point_data":[{"data":"point_data","x":1,"y":0.2,"_row":1},{"data":"point_data","x":1.1,"y":0.1,"_row":2},{"data":"point_data","x":1.2,"y":0.2,"_row":3},{"data":"point_data","x":1.2,"y":0.2,"_row":4},{"data":"point_data","x":1.3,"y":0.2,"_row":5},{"data":"point_data","x":1.3,"y":0.4,"_row":6},{"data":"point_data","x":1.3,"y":0.2,"_row":7},{"data":"point_data","x":1.3,"y":0.2,"_row":8},{"data":"point_data","x":1.3,"y":0.3,"_row":9},{"data":"point_data","x":1.3,"y":0.3,"_row":10},{"data":"point_data","x":1.3,"y":0.2,"_row":11},{"data":"point_data","x":1.4,"y":0.2,"_row":12},{"data":"point_data","x":1.4,"y":0.2,"_row":13},{"data":"point_data","x":1.4,"y":0.2,"_row":14},{"data":"point_data","x":1.4,"y":0.3,"_row":15},{"data":"point_data","x":1.4,"y":0.2,"_row":16},{"data":"point_data","x":1.4,"y":0.1,"_row":17},{"data":"point_data","x":1.4,"y":0.3,"_row":18},{"data":"point_data","x":1.4,"y":0.2,"_row":19},{"data":"point_data","x":1.4,"y":0.2,"_row":20},{"data":"point_data","x":1.4,"y":0.1,"_row":21},{"data":"point_data","x":1.4,"y":0.3,"_row":22},{"data":"point_data","x":1.4,"y":0.2,"_row":23},{"data":"point_data","x":1.4,"y":0.2,"_row":24},{"data":"point_data","x":1.5,"y":0.2,"_row":25},{"data":"point_data","x":1.5,"y":0.2,"_row":26},{"data":"point_data","x":1.5,"y":0.1,"_row":27},{"data":"point_data","x":1.5,"y":0.2,"_row":28},{"data":"point_data","x":1.5,"y":0.4,"_row":29},{"data":"point_data","x":1.5,"y":0.3,"_row":30},{"data":"point_data","x":1.5,"y":0.4,"_row":31},{"data":"point_data","x":1.5,"y":0.2,"_row":32},{"data":"point_data","x":1.5,"y":0.4,"_row":33},{"data":"point_data","x":1.5,"y":0.1,"_row":34},{"data":"point_data","x":1.5,"y":0.2,"_row":35},{"data":"point_data","x":1.5,"y":0.2,"_row":36},{"data":"point_data","x":1.5,"y":0.2,"_row":37},{"data":"point_data","x":1.6,"y":0.2,"_row":38},{"data":"point_data","x":1.6,"y":0.2,"_row":39},{"data":"point_data","x":1.6,"y":0.4,"_row":40},{"data":"point_data","x":1.6,"y":0.2,"_row":41},{"data":"point_data","x":1.6,"y":0.2,"_row":42},{"data":"point_data","x":1.6,"y":0.6,"_row":43},{"data":"point_data","x":1.6,"y":0.2,"_row":44},{"data":"point_data","x":1.7,"y":0.4,"_row":45},{"data":"point_data","x":1.7,"y":0.3,"_row":46},{"data":"point_data","x":1.7,"y":0.2,"_row":47},{"data":"point_data","x":1.7,"y":0.5,"_row":48},{"data":"point_data","x":1.9,"y":0.2,"_row":49},{"data":"point_data","x":1.9,"y":0.4,"_row":50},{"data":"point_data","x":3,"y":1.1,"_row":51},{"data":"point_data","x":3.3,"y":1,"_row":52},{"data":"point_data","x":3.3,"y":1,"_row":53},{"data":"point_data","x":3.5,"y":1,"_row":54},{"data":"point_data","x":3.5,"y":1,"_row":55},{"data":"point_data","x":3.6,"y":1.3,"_row":56},{"data":"point_data","x":3.7,"y":1,"_row":57},{"data":"point_data","x":3.8,"y":1.1,"_row":58},{"data":"point_data","x":3.9,"y":1.4,"_row":59},{"data":"point_data","x":3.9,"y":1.1,"_row":60},{"data":"point_data","x":3.9,"y":1.2,"_row":61},{"data":"point_data","x":4,"y":1.3,"_row":62},{"data":"point_data","x":4,"y":1,"_row":63},{"data":"point_data","x":4,"y":1.3,"_row":64},{"data":"point_data","x":4,"y":1.3,"_row":65},{"data":"point_data","x":4,"y":1.2,"_row":66},{"data":"point_data","x":4.1,"y":1,"_row":67},{"data":"point_data","x":4.1,"y":1.3,"_row":68},{"data":"point_data","x":4.1,"y":1.3,"_row":69},{"data":"point_data","x":4.2,"y":1.5,"_row":70},{"data":"point_data","x":4.2,"y":1.3,"_row":71},{"data":"point_data","x":4.2,"y":1.2,"_row":72},{"data":"point_data","x":4.2,"y":1.3,"_row":73},{"data":"point_data","x":4.3,"y":1.3,"_row":74},{"data":"point_data","x":4.3,"y":1.3,"_row":75},{"data":"point_data","x":4.4,"y":1.4,"_row":76},{"data":"point_data","x":4.4,"y":1.4,"_row":77},{"data":"point_data","x":4.4,"y":1.3,"_row":78},{"data":"point_data","x":4.4,"y":1.2,"_row":79},{"data":"point_data","x":4.5,"y":1.5,"_row":80},{"data":"point_data","x":4.5,"y":1.3,"_row":81},{"data":"point_data","x":4.5,"y":1.5,"_row":82},{"data":"point_data","x":4.5,"y":1.5,"_row":83},{"data":"point_data","x":4.5,"y":1.5,"_row":84},{"data":"point_data","x":4.5,"y":1.5,"_row":85},{"data":"point_data","x":4.5,"y":1.6,"_row":86},{"data":"point_data","x":4.5,"y":1.7,"_row":87},{"data":"point_data","x":4.6,"y":1.5,"_row":88},{"data":"point_data","x":4.6,"y":1.3,"_row":89},{"data":"point_data","x":4.6,"y":1.4,"_row":90},{"data":"point_data","x":4.7,"y":1.4,"_row":91},{"data":"point_data","x":4.7,"y":1.6,"_row":92},{"data":"point_data","x":4.7,"y":1.4,"_row":93},{"data":"point_data","x":4.7,"y":1.2,"_row":94},{"data":"point_data","x":4.7,"y":1.5,"_row":95},{"data":"point_data","x":4.8,"y":1.8,"_row":96},{"data":"point_data","x":4.8,"y":1.4,"_row":97},{"data":"point_data","x":4.8,"y":1.8,"_row":98},{"data":"point_data","x":4.8,"y":1.8,"_row":99},{"data":"point_data","x":4.9,"y":1.5,"_row":100},{"data":"point_data","x":4.9,"y":1.5,"_row":101},{"data":"point_data","x":4.9,"y":2,"_row":102},{"data":"point_data","x":4.9,"y":1.8,"_row":103},{"data":"point_data","x":4.9,"y":1.8,"_row":104},{"data":"point_data","x":5,"y":1.7,"_row":105},{"data":"point_data","x":5,"y":2,"_row":106},{"data":"point_data","x":5,"y":1.5,"_row":107},{"data":"point_data","x":5,"y":1.9,"_row":108},{"data":"point_data","x":5.1,"y":1.6,"_row":109},{"data":"point_data","x":5.1,"y":1.9,"_row":110},{"data":"point_data","x":5.1,"y":2,"_row":111},{"data":"point_data","x":5.1,"y":2.4,"_row":112},{"data":"point_data","x":5.1,"y":1.5,"_row":113},{"data":"point_data","x":5.1,"y":2.3,"_row":114},{"data":"point_data","x":5.1,"y":1.9,"_row":115},{"data":"point_data","x":5.1,"y":1.8,"_row":116},{"data":"point_data","x":5.2,"y":2.3,"_row":117},{"data":"point_data","x":5.2,"y":2,"_row":118},{"data":"point_data","x":5.3,"y":1.9,"_row":119},{"data":"point_data","x":5.3,"y":2.3,"_row":120},{"data":"point_data","x":5.4,"y":2.1,"_row":121},{"data":"point_data","x":5.4,"y":2.3,"_row":122},{"data":"point_data","x":5.5,"y":2.1,"_row":123},{"data":"point_data","x":5.5,"y":1.8,"_row":124},{"data":"point_data","x":5.5,"y":1.8,"_row":125},{"data":"point_data","x":5.6,"y":1.8,"_row":126},{"data":"point_data","x":5.6,"y":2.1,"_row":127},{"data":"point_data","x":5.6,"y":2.2,"_row":128},{"data":"point_data","x":5.6,"y":1.4,"_row":129},{"data":"point_data","x":5.6,"y":2.4,"_row":130},{"data":"point_data","x":5.6,"y":2.4,"_row":131},{"data":"point_data","x":5.7,"y":2.3,"_row":132},{"data":"point_data","x":5.7,"y":2.1,"_row":133},{"data":"point_data","x":5.7,"y":2.5,"_row":134},{"data":"point_data","x":5.8,"y":2.2,"_row":135},{"data":"point_data","x":5.8,"y":1.8,"_row":136},{"data":"point_data","x":5.8,"y":1.6,"_row":137},{"data":"point_data","x":5.9,"y":2.1,"_row":138},{"data":"point_data","x":5.9,"y":2.3,"_row":139},{"data":"point_data","x":6,"y":2.5,"_row":140},{"data":"point_data","x":6,"y":1.8,"_row":141},{"data":"point_data","x":6.1,"y":2.5,"_row":142},{"data":"point_data","x":6.1,"y":1.9,"_row":143},{"data":"point_data","x":6.1,"y":2.3,"_row":144},{"data":"point_data","x":6.3,"y":1.8,"_row":145},{"data":"point_data","x":6.4,"y":2,"_row":146},{"data":"point_data","x":6.6,"y":2.1,"_row":147},{"data":"point_data","x":6.7,"y":2.2,"_row":148},{"data":"point_data","x":6.7,"y":2,"_row":149},{"data":"point_data","x":6.9,"y":2.3,"_row":150}],"lower_bound":[{"x":1,"y":-0.0093,"_row":1},{"x":1.1,"y":0.0339,"_row":2},{"x":1.2,"y":0.077,"_row":3},{"x":1.2,"y":0.077,"_row":4},{"x":1.3,"y":0.1202,"_row":5},{"x":1.3,"y":0.1202,"_row":6},{"x":1.3,"y":0.1202,"_row":7},{"x":1.3,"y":0.1202,"_row":8},{"x":1.3,"y":0.1202,"_row":9},{"x":1.3,"y":0.1202,"_row":10},{"x":1.3,"y":0.1202,"_row":11},{"x":1.4,"y":0.1633,"_row":12},{"x":1.4,"y":0.1633,"_row":13},{"x":1.4,"y":0.1633,"_row":14},{"x":1.4,"y":0.1633,"_row":15},{"x":1.4,"y":0.1633,"_row":16},{"x":1.4,"y":0.1633,"_row":17},{"x":1.4,"y":0.1633,"_row":18},{"x":1.4,"y":0.1633,"_row":19},{"x":1.4,"y":0.1633,"_row":20},{"x":1.4,"y":0.1633,"_row":21},{"x":1.4,"y":0.1633,"_row":22},{"x":1.4,"y":0.1633,"_row":23},{"x":1.4,"y":0.1633,"_row":24},{"x":1.5,"y":0.2064,"_row":25},{"x":1.5,"y":0.2064,"_row":26},{"x":1.5,"y":0.2064,"_row":27},{"x":1.5,"y":0.2064,"_row":28},{"x":1.5,"y":0.2064,"_row":29},{"x":1.5,"y":0.2064,"_row":30},{"x":1.5,"y":0.2064,"_row":31},{"x":1.5,"y":0.2064,"_row":32},{"x":1.5,"y":0.2064,"_row":33},{"x":1.5,"y":0.2064,"_row":34},{"x":1.5,"y":0.2064,"_row":35},{"x":1.5,"y":0.2064,"_row":36},{"x":1.5,"y":0.2064,"_row":37},{"x":1.6,"y":0.2494,"_row":38},{"x":1.6,"y":0.2494,"_row":39},{"x":1.6,"y":0.2494,"_row":40},{"x":1.6,"y":0.2494,"_row":41},{"x":1.6,"y":0.2494,"_row":42},{"x":1.6,"y":0.2494,"_row":43},{"x":1.6,"y":0.2494,"_row":44},{"x":1.7,"y":0.2924,"_row":45},{"x":1.7,"y":0.2924,"_row":46},{"x":1.7,"y":0.2924,"_row":47},{"x":1.7,"y":0.2924,"_row":48},{"x":1.9,"y":0.3784,"_row":49},{"x":1.9,"y":0.3784,"_row":50},{"x":3,"y":0.8479,"_row":51},{"x":3.3,"y":0.9745,"_row":52},{"x":3.3,"y":0.9745,"_row":53},{"x":3.5,"y":1.0584,"_row":54},{"x":3.5,"y":1.0584,"_row":55},{"x":3.6,"y":1.1002,"_row":56},{"x":3.7,"y":1.1419,"_row":57},{"x":3.8,"y":1.1835,"_row":58},{"x":3.9,"y":1.2249,"_row":59},{"x":3.9,"y":1.2249,"_row":60},{"x":3.9,"y":1.2249,"_row":61},{"x":4,"y":1.2663,"_row":62},{"x":4,"y":1.2663,"_row":63},{"x":4,"y":1.2663,"_row":64},{"x":4,"y":1.2663,"_row":65},{"x":4,"y":1.2663,"_row":66},{"x":4.1,"y":1.3076,"_row":67},{"x":4.1,"y":1.3076,"_row":68},{"x":4.1,"y":1.3076,"_row":69},{"x":4.2,"y":1.3487,"_row":70},{"x":4.2,"y":1.3487,"_row":71},{"x":4.2,"y":1.3487,"_row":72},{"x":4.2,"y":1.3487,"_row":73},{"x":4.3,"y":1.3898,"_row":74},{"x":4.3,"y":1.3898,"_row":75},{"x":4.4,"y":1.4308,"_row":76},{"x":4.4,"y":1.4308,"_row":77},{"x":4.4,"y":1.4308,"_row":78},{"x":4.4,"y":1.4308,"_row":79},{"x":4.5,"y":1.4717,"_row":80},{"x":4.5,"y":1.4717,"_row":81},{"x":4.5,"y":1.4717,"_row":82},{"x":4.5,"y":1.4717,"_row":83},{"x":4.5,"y":1.4717,"_row":84},{"x":4.5,"y":1.4717,"_row":85},{"x":4.5,"y":1.4717,"_row":86},{"x":4.5,"y":1.4717,"_row":87},{"x":4.6,"y":1.5125,"_row":88},{"x":4.6,"y":1.5125,"_row":89},{"x":4.6,"y":1.5125,"_row":90},{"x":4.7,"y":1.5532,"_row":91},{"x":4.7,"y":1.5532,"_row":92},{"x":4.7,"y":1.5532,"_row":93},{"x":4.7,"y":1.5532,"_row":94},{"x":4.7,"y":1.5532,"_row":95},{"x":4.8,"y":1.5938,"_row":96},{"x":4.8,"y":1.5938,"_row":97},{"x":4.8,"y":1.5938,"_row":98},{"x":4.8,"y":1.5938,"_row":99},{"x":4.9,"y":1.6344,"_row":100},{"x":4.9,"y":1.6344,"_row":101},{"x":4.9,"y":1.6344,"_row":102},{"x":4.9,"y":1.6344,"_row":103},{"x":4.9,"y":1.6344,"_row":104},{"x":5,"y":1.6749,"_row":105},{"x":5,"y":1.6749,"_row":106},{"x":5,"y":1.6749,"_row":107},{"x":5,"y":1.6749,"_row":108},{"x":5.1,"y":1.7154,"_row":109},{"x":5.1,"y":1.7154,"_row":110},{"x":5.1,"y":1.7154,"_row":111},{"x":5.1,"y":1.7154,"_row":112},{"x":5.1,"y":1.7154,"_row":113},{"x":5.1,"y":1.7154,"_row":114},{"x":5.1,"y":1.7154,"_row":115},{"x":5.1,"y":1.7154,"_row":116},{"x":5.2,"y":1.7558,"_row":117},{"x":5.2,"y":1.7558,"_row":118},{"x":5.3,"y":1.7961,"_row":119},{"x":5.3,"y":1.7961,"_row":120},{"x":5.4,"y":1.8364,"_row":121},{"x":5.4,"y":1.8364,"_row":122},{"x":5.5,"y":1.8767,"_row":123},{"x":5.5,"y":1.8767,"_row":124},{"x":5.5,"y":1.8767,"_row":125},{"x":5.6,"y":1.9169,"_row":126},{"x":5.6,"y":1.9169,"_row":127},{"x":5.6,"y":1.9169,"_row":128},{"x":5.6,"y":1.9169,"_row":129},{"x":5.6,"y":1.9169,"_row":130},{"x":5.6,"y":1.9169,"_row":131},{"x":5.7,"y":1.9571,"_row":132},{"x":5.7,"y":1.9571,"_row":133},{"x":5.7,"y":1.9571,"_row":134},{"x":5.8,"y":1.9973,"_row":135},{"x":5.8,"y":1.9973,"_row":136},{"x":5.8,"y":1.9973,"_row":137},{"x":5.9,"y":2.0374,"_row":138},{"x":5.9,"y":2.0374,"_row":139},{"x":6,"y":2.0775,"_row":140},{"x":6,"y":2.0775,"_row":141},{"x":6.1,"y":2.1176,"_row":142},{"x":6.1,"y":2.1176,"_row":143},{"x":6.1,"y":2.1176,"_row":144},{"x":6.3,"y":2.1976,"_row":145},{"x":6.4,"y":2.2377,"_row":146},{"x":6.6,"y":2.3176,"_row":147},{"x":6.7,"y":2.3576,"_row":148},{"x":6.7,"y":2.3576,"_row":149},{"x":6.9,"y":2.4374,"_row":150}],"upper_bound":[{"x":1,"y":0.1146,"_row":1},{"x":1.1,"y":0.1546,"_row":2},{"x":1.2,"y":0.1946,"_row":3},{"x":1.2,"y":0.1946,"_row":4},{"x":1.3,"y":0.2346,"_row":5},{"x":1.3,"y":0.2346,"_row":6},{"x":1.3,"y":0.2346,"_row":7},{"x":1.3,"y":0.2346,"_row":8},{"x":1.3,"y":0.2346,"_row":9},{"x":1.3,"y":0.2346,"_row":10},{"x":1.3,"y":0.2346,"_row":11},{"x":1.4,"y":0.2747,"_row":12},{"x":1.4,"y":0.2747,"_row":13},{"x":1.4,"y":0.2747,"_row":14},{"x":1.4,"y":0.2747,"_row":15},{"x":1.4,"y":0.2747,"_row":16},{"x":1.4,"y":0.2747,"_row":17},{"x":1.4,"y":0.2747,"_row":18},{"x":1.4,"y":0.2747,"_row":19},{"x":1.4,"y":0.2747,"_row":20},{"x":1.4,"y":0.2747,"_row":21},{"x":1.4,"y":0.2747,"_row":22},{"x":1.4,"y":0.2747,"_row":23},{"x":1.4,"y":0.2747,"_row":24},{"x":1.5,"y":0.3148,"_row":25},{"x":1.5,"y":0.3148,"_row":26},{"x":1.5,"y":0.3148,"_row":27},{"x":1.5,"y":0.3148,"_row":28},{"x":1.5,"y":0.3148,"_row":29},{"x":1.5,"y":0.3148,"_row":30},{"x":1.5,"y":0.3148,"_row":31},{"x":1.5,"y":0.3148,"_row":32},{"x":1.5,"y":0.3148,"_row":33},{"x":1.5,"y":0.3148,"_row":34},{"x":1.5,"y":0.3148,"_row":35},{"x":1.5,"y":0.3148,"_row":36},{"x":1.5,"y":0.3148,"_row":37},{"x":1.6,"y":0.3549,"_row":38},{"x":1.6,"y":0.3549,"_row":39},{"x":1.6,"y":0.3549,"_row":40},{"x":1.6,"y":0.3549,"_row":41},{"x":1.6,"y":0.3549,"_row":42},{"x":1.6,"y":0.3549,"_row":43},{"x":1.6,"y":0.3549,"_row":44},{"x":1.7,"y":0.395,"_row":45},{"x":1.7,"y":0.395,"_row":46},{"x":1.7,"y":0.395,"_row":47},{"x":1.7,"y":0.395,"_row":48},{"x":1.9,"y":0.4753,"_row":49},{"x":1.9,"y":0.4753,"_row":50},{"x":3,"y":0.9205,"_row":51},{"x":3.3,"y":1.0433,"_row":52},{"x":3.3,"y":1.0433,"_row":53},{"x":3.5,"y":1.1257,"_row":54},{"x":3.5,"y":1.1257,"_row":55},{"x":3.6,"y":1.1671,"_row":56},{"x":3.7,"y":1.2086,"_row":57},{"x":3.8,"y":1.2501,"_row":58},{"x":3.9,"y":1.2918,"_row":59},{"x":3.9,"y":1.2918,"_row":60},{"x":3.9,"y":1.2918,"_row":61},{"x":4,"y":1.3336,"_row":62},{"x":4,"y":1.3336,"_row":63},{"x":4,"y":1.3336,"_row":64},{"x":4,"y":1.3336,"_row":65},{"x":4,"y":1.3336,"_row":66},{"x":4.1,"y":1.3755,"_row":67},{"x":4.1,"y":1.3755,"_row":68},{"x":4.1,"y":1.3755,"_row":69},{"x":4.2,"y":1.4174,"_row":70},{"x":4.2,"y":1.4174,"_row":71},{"x":4.2,"y":1.4174,"_row":72},{"x":4.2,"y":1.4174,"_row":73},{"x":4.3,"y":1.4595,"_row":74},{"x":4.3,"y":1.4595,"_row":75},{"x":4.4,"y":1.5017,"_row":76},{"x":4.4,"y":1.5017,"_row":77},{"x":4.4,"y":1.5017,"_row":78},{"x":4.4,"y":1.5017,"_row":79},{"x":4.5,"y":1.544,"_row":80},{"x":4.5,"y":1.544,"_row":81},{"x":4.5,"y":1.544,"_row":82},{"x":4.5,"y":1.544,"_row":83},{"x":4.5,"y":1.544,"_row":84},{"x":4.5,"y":1.544,"_row":85},{"x":4.5,"y":1.544,"_row":86},{"x":4.5,"y":1.544,"_row":87},{"x":4.6,"y":1.5863,"_row":88},{"x":4.6,"y":1.5863,"_row":89},{"x":4.6,"y":1.5863,"_row":90},{"x":4.7,"y":1.6288,"_row":91},{"x":4.7,"y":1.6288,"_row":92},{"x":4.7,"y":1.6288,"_row":93},{"x":4.7,"y":1.6288,"_row":94},{"x":4.7,"y":1.6288,"_row":95},{"x":4.8,"y":1.6713,"_row":96},{"x":4.8,"y":1.6713,"_row":97},{"x":4.8,"y":1.6713,"_row":98},{"x":4.8,"y":1.6713,"_row":99},{"x":4.9,"y":1.7138,"_row":100},{"x":4.9,"y":1.7138,"_row":101},{"x":4.9,"y":1.7138,"_row":102},{"x":4.9,"y":1.7138,"_row":103},{"x":4.9,"y":1.7138,"_row":104},{"x":5,"y":1.7565,"_row":105},{"x":5,"y":1.7565,"_row":106},{"x":5,"y":1.7565,"_row":107},{"x":5,"y":1.7565,"_row":108},{"x":5.1,"y":1.7992,"_row":109},{"x":5.1,"y":1.7992,"_row":110},{"x":5.1,"y":1.7992,"_row":111},{"x":5.1,"y":1.7992,"_row":112},{"x":5.1,"y":1.7992,"_row":113},{"x":5.1,"y":1.7992,"_row":114},{"x":5.1,"y":1.7992,"_row":115},{"x":5.1,"y":1.7992,"_row":116},{"x":5.2,"y":1.8419,"_row":117},{"x":5.2,"y":1.8419,"_row":118},{"x":5.3,"y":1.8847,"_row":119},{"x":5.3,"y":1.8847,"_row":120},{"x":5.4,"y":1.9276,"_row":121},{"x":5.4,"y":1.9276,"_row":122},{"x":5.5,"y":1.9705,"_row":123},{"x":5.5,"y":1.9705,"_row":124},{"x":5.5,"y":1.9705,"_row":125},{"x":5.6,"y":2.0134,"_row":126},{"x":5.6,"y":2.0134,"_row":127},{"x":5.6,"y":2.0134,"_row":128},{"x":5.6,"y":2.0134,"_row":129},{"x":5.6,"y":2.0134,"_row":130},{"x":5.6,"y":2.0134,"_row":131},{"x":5.7,"y":2.0564,"_row":132},{"x":5.7,"y":2.0564,"_row":133},{"x":5.7,"y":2.0564,"_row":134},{"x":5.8,"y":2.0993,"_row":135},{"x":5.8,"y":2.0993,"_row":136},{"x":5.8,"y":2.0993,"_row":137},{"x":5.9,"y":2.1424,"_row":138},{"x":5.9,"y":2.1424,"_row":139},{"x":6,"y":2.1854,"_row":140},{"x":6,"y":2.1854,"_row":141},{"x":6.1,"y":2.2285,"_row":142},{"x":6.1,"y":2.2285,"_row":143},{"x":6.1,"y":2.2285,"_row":144},{"x":6.3,"y":2.3147,"_row":145},{"x":6.4,"y":2.3579,"_row":146},{"x":6.6,"y":2.4442,"_row":147},{"x":6.7,"y":2.4874,"_row":148},{"x":6.7,"y":2.4874,"_row":149},{"x":6.9,"y":2.5738,"_row":150}]},"type":"json","container":"svg","options":{"draw_start":1,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[1,6.9],"x_by":0,"x_lab":"Petal Width","y_range":[-0.06996795279057878,2.628284699336572],"y_lab":"","subtitle":"Petal Length","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Petal Width vs Petal Length","conf_int":true},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>Try drawing for yourself in the plot above! See if you can replicate
the regression line. Additionally, you can also draw the 95% confidence
interval boundaries using the “new line” button. Have fun experimenting
with this interactive plot!</p>
</div>
<div class="section level2">
<h2 id="different-regression-options">Different Regression Options<a class="anchor" aria-label="anchor" href="#different-regression-options"></a>
</h2>
<p>The <code><a href="../reference/customDataGen.html">customDataGen()</a></code> currently offers four regression
options: linear, polynomial, logistic, and loess. Since we already saw
linear let’s take a look at the others.</p>
<div class="section level3">
<h3 id="logistic-regression">Logistic Regression<a class="anchor" aria-label="anchor" href="#logistic-regression"></a>
</h3>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Convert Species into a binary categorical variable</span></span>
<span><span class="va">iris</span><span class="op">$</span><span class="va">binary_species</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">iris</span><span class="op">$</span><span class="va">Species</span> <span class="op">==</span> <span class="st">"setosa"</span>, <span class="st">"setosa"</span>, <span class="st">"other"</span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/customDataGen.html">customDataGen()</a></code> function can only generate logistic
regression data for binary categorical variables. In this case we will
use either setosa or other for species. You do not need to worry about
changing this variable to a factor as the customDataGen function will do
it for you.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Generate custom data for logistic regression</span></span>
<span><span class="va">custom_data_logistic</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">iris</span>,</span>
<span>  xvar <span class="op">=</span> <span class="st">"Sepal.Length"</span>,  <span class="co"># Predictor variable (numeric): Sepal length in centimeters</span></span>
<span>  yvar <span class="op">=</span> <span class="st">"binary_species"</span>, <span class="co"># Response variable (binary categorical): Setosa (1) or Other (0)</span></span>
<span>  regression_type <span class="op">=</span> <span class="st">"logistic"</span>,</span>
<span>  success_level <span class="op">=</span> <span class="st">"setosa"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The success_level argument specifies which of the two levels of the
binary response variable is considered as the “event” or “success”. In
this case, we are interested in the occurrence of the ‘setosa’ species,
and so we set “setosa” as the success_level.</p>
<p>If success_level is not provided, the function will default to using
the first level of the binary response variable, sorted alphabetically.
So, if your binary response has levels “yes” and “no”, and you do not
specify a success_level, the function will treat “no” as the “success”
level, since “no” comes before “yes” alphabetically.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data_logistic</span>,</span>
<span>      title <span class="op">=</span> <span class="st">"Probability of 'Setosa' Species Based on Sepal Length"</span>,</span>
<span>      aspect_ratio <span class="op">=</span> <span class="fl">1.2</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-e02da4182c036211efd0" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-e02da4182c036211efd0">{"x":{"data":{"line_data":[{"data":"line_data","x":4.3,"y":0.0038,"coef":5.1757,"int":"-27.8285213953677","_row":1},{"data":"line_data","x":4.4,"y":0.0063,"coef":5.1757,"int":"-27.8285213953677","_row":2},{"data":"line_data","x":4.4,"y":0.0063,"coef":5.1757,"int":"-27.8285213953677","_row":3},{"data":"line_data","x":4.4,"y":0.0063,"coef":5.1757,"int":"-27.8285213953677","_row":4},{"data":"line_data","x":4.5,"y":0.0106,"coef":5.1757,"int":"-27.8285213953677","_row":5},{"data":"line_data","x":4.6,"y":0.0176,"coef":5.1757,"int":"-27.8285213953677","_row":6},{"data":"line_data","x":4.6,"y":0.0176,"coef":5.1757,"int":"-27.8285213953677","_row":7},{"data":"line_data","x":4.6,"y":0.0176,"coef":5.1757,"int":"-27.8285213953677","_row":8},{"data":"line_data","x":4.6,"y":0.0176,"coef":5.1757,"int":"-27.8285213953677","_row":9},{"data":"line_data","x":4.7,"y":0.0292,"coef":5.1757,"int":"-27.8285213953677","_row":10},{"data":"line_data","x":4.7,"y":0.0292,"coef":5.1757,"int":"-27.8285213953677","_row":11},{"data":"line_data","x":4.8,"y":0.0481,"coef":5.1757,"int":"-27.8285213953677","_row":12},{"data":"line_data","x":4.8,"y":0.0481,"coef":5.1757,"int":"-27.8285213953677","_row":13},{"data":"line_data","x":4.8,"y":0.0481,"coef":5.1757,"int":"-27.8285213953677","_row":14},{"data":"line_data","x":4.8,"y":0.0481,"coef":5.1757,"int":"-27.8285213953677","_row":15},{"data":"line_data","x":4.8,"y":0.0481,"coef":5.1757,"int":"-27.8285213953677","_row":16},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":17},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":18},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":19},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":20},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":21},{"data":"line_data","x":4.9,"y":0.0782,"coef":5.1757,"int":"-27.8285213953677","_row":22},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":23},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":24},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":25},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":26},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":27},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":28},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":29},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":30},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":31},{"data":"line_data","x":5,"y":0.1246,"coef":5.1757,"int":"-27.8285213953677","_row":32},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":33},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":34},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":35},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":36},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":37},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":38},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":39},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":40},{"data":"line_data","x":5.1,"y":0.1927,"coef":5.1757,"int":"-27.8285213953677","_row":41},{"data":"line_data","x":5.2,"y":0.286,"coef":5.1757,"int":"-27.8285213953677","_row":42},{"data":"line_data","x":5.2,"y":0.286,"coef":5.1757,"int":"-27.8285213953677","_row":43},{"data":"line_data","x":5.2,"y":0.286,"coef":5.1757,"int":"-27.8285213953677","_row":44},{"data":"line_data","x":5.2,"y":0.286,"coef":5.1757,"int":"-27.8285213953677","_row":45},{"data":"line_data","x":5.3,"y":0.402,"coef":5.1757,"int":"-27.8285213953677","_row":46},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":47},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":48},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":49},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":50},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":51},{"data":"line_data","x":5.4,"y":0.53,"coef":5.1757,"int":"-27.8285213953677","_row":52},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":53},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":54},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":55},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":56},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":57},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":58},{"data":"line_data","x":5.5,"y":0.6543,"coef":5.1757,"int":"-27.8285213953677","_row":59},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":60},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":61},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":62},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":63},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":64},{"data":"line_data","x":5.6,"y":0.7605,"coef":5.1757,"int":"-27.8285213953677","_row":65},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":66},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":67},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":68},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":69},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":70},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":71},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":72},{"data":"line_data","x":5.7,"y":0.842,"coef":5.1757,"int":"-27.8285213953677","_row":73},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":74},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":75},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":76},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":77},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":78},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":79},{"data":"line_data","x":5.8,"y":0.8994,"coef":5.1757,"int":"-27.8285213953677","_row":80},{"data":"line_data","x":5.9,"y":0.9375,"coef":5.1757,"int":"-27.8285213953677","_row":81},{"data":"line_data","x":5.9,"y":0.9375,"coef":5.1757,"int":"-27.8285213953677","_row":82},{"data":"line_data","x":5.9,"y":0.9375,"coef":5.1757,"int":"-27.8285213953677","_row":83},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":84},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":85},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":86},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":87},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":88},{"data":"line_data","x":6,"y":0.9618,"coef":5.1757,"int":"-27.8285213953677","_row":89},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":90},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":91},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":92},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":93},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":94},{"data":"line_data","x":6.1,"y":0.9769,"coef":5.1757,"int":"-27.8285213953677","_row":95},{"data":"line_data","x":6.2,"y":0.9861,"coef":5.1757,"int":"-27.8285213953677","_row":96},{"data":"line_data","x":6.2,"y":0.9861,"coef":5.1757,"int":"-27.8285213953677","_row":97},{"data":"line_data","x":6.2,"y":0.9861,"coef":5.1757,"int":"-27.8285213953677","_row":98},{"data":"line_data","x":6.2,"y":0.9861,"coef":5.1757,"int":"-27.8285213953677","_row":99},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":100},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":101},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":102},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":103},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":104},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":105},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":106},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":107},{"data":"line_data","x":6.3,"y":0.9917,"coef":5.1757,"int":"-27.8285213953677","_row":108},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":109},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":110},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":111},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":112},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":113},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":114},{"data":"line_data","x":6.4,"y":0.995,"coef":5.1757,"int":"-27.8285213953677","_row":115},{"data":"line_data","x":6.5,"y":0.997,"coef":5.1757,"int":"-27.8285213953677","_row":116},{"data":"line_data","x":6.5,"y":0.997,"coef":5.1757,"int":"-27.8285213953677","_row":117},{"data":"line_data","x":6.5,"y":0.997,"coef":5.1757,"int":"-27.8285213953677","_row":118},{"data":"line_data","x":6.5,"y":0.997,"coef":5.1757,"int":"-27.8285213953677","_row":119},{"data":"line_data","x":6.5,"y":0.997,"coef":5.1757,"int":"-27.8285213953677","_row":120},{"data":"line_data","x":6.6,"y":0.9982,"coef":5.1757,"int":"-27.8285213953677","_row":121},{"data":"line_data","x":6.6,"y":0.9982,"coef":5.1757,"int":"-27.8285213953677","_row":122},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":123},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":124},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":125},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":126},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":127},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":128},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":129},{"data":"line_data","x":6.7,"y":0.9989,"coef":5.1757,"int":"-27.8285213953677","_row":130},{"data":"line_data","x":6.8,"y":0.9994,"coef":5.1757,"int":"-27.8285213953677","_row":131},{"data":"line_data","x":6.8,"y":0.9994,"coef":5.1757,"int":"-27.8285213953677","_row":132},{"data":"line_data","x":6.8,"y":0.9994,"coef":5.1757,"int":"-27.8285213953677","_row":133},{"data":"line_data","x":6.9,"y":0.9996,"coef":5.1757,"int":"-27.8285213953677","_row":134},{"data":"line_data","x":6.9,"y":0.9996,"coef":5.1757,"int":"-27.8285213953677","_row":135},{"data":"line_data","x":6.9,"y":0.9996,"coef":5.1757,"int":"-27.8285213953677","_row":136},{"data":"line_data","x":6.9,"y":0.9996,"coef":5.1757,"int":"-27.8285213953677","_row":137},{"data":"line_data","x":7,"y":0.9998,"coef":5.1757,"int":"-27.8285213953677","_row":138},{"data":"line_data","x":7.1,"y":0.9999,"coef":5.1757,"int":"-27.8285213953677","_row":139},{"data":"line_data","x":7.2,"y":0.9999,"coef":5.1757,"int":"-27.8285213953677","_row":140},{"data":"line_data","x":7.2,"y":0.9999,"coef":5.1757,"int":"-27.8285213953677","_row":141},{"data":"line_data","x":7.2,"y":0.9999,"coef":5.1757,"int":"-27.8285213953677","_row":142},{"data":"line_data","x":7.3,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":143},{"data":"line_data","x":7.4,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":144},{"data":"line_data","x":7.6,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":145},{"data":"line_data","x":7.7,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":146},{"data":"line_data","x":7.7,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":147},{"data":"line_data","x":7.7,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":148},{"data":"line_data","x":7.7,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":149},{"data":"line_data","x":7.9,"y":1,"coef":5.1757,"int":"-27.8285213953677","_row":150}],"point_data":[{"data":"point_data","x":4.3,"y":0,"_row":1},{"data":"point_data","x":4.4,"y":0,"_row":2},{"data":"point_data","x":4.4,"y":0,"_row":3},{"data":"point_data","x":4.4,"y":0,"_row":4},{"data":"point_data","x":4.5,"y":0,"_row":5},{"data":"point_data","x":4.6,"y":0,"_row":6},{"data":"point_data","x":4.6,"y":0,"_row":7},{"data":"point_data","x":4.6,"y":0,"_row":8},{"data":"point_data","x":4.6,"y":0,"_row":9},{"data":"point_data","x":4.7,"y":0,"_row":10},{"data":"point_data","x":4.7,"y":0,"_row":11},{"data":"point_data","x":4.8,"y":0,"_row":12},{"data":"point_data","x":4.8,"y":0,"_row":13},{"data":"point_data","x":4.8,"y":0,"_row":14},{"data":"point_data","x":4.8,"y":0,"_row":15},{"data":"point_data","x":4.8,"y":0,"_row":16},{"data":"point_data","x":4.9,"y":0,"_row":17},{"data":"point_data","x":4.9,"y":0,"_row":18},{"data":"point_data","x":4.9,"y":0,"_row":19},{"data":"point_data","x":4.9,"y":0,"_row":20},{"data":"point_data","x":4.9,"y":1,"_row":21},{"data":"point_data","x":4.9,"y":1,"_row":22},{"data":"point_data","x":5,"y":0,"_row":23},{"data":"point_data","x":5,"y":0,"_row":24},{"data":"point_data","x":5,"y":0,"_row":25},{"data":"point_data","x":5,"y":0,"_row":26},{"data":"point_data","x":5,"y":0,"_row":27},{"data":"point_data","x":5,"y":0,"_row":28},{"data":"point_data","x":5,"y":0,"_row":29},{"data":"point_data","x":5,"y":0,"_row":30},{"data":"point_data","x":5,"y":1,"_row":31},{"data":"point_data","x":5,"y":1,"_row":32},{"data":"point_data","x":5.1,"y":0,"_row":33},{"data":"point_data","x":5.1,"y":0,"_row":34},{"data":"point_data","x":5.1,"y":0,"_row":35},{"data":"point_data","x":5.1,"y":0,"_row":36},{"data":"point_data","x":5.1,"y":0,"_row":37},{"data":"point_data","x":5.1,"y":0,"_row":38},{"data":"point_data","x":5.1,"y":0,"_row":39},{"data":"point_data","x":5.1,"y":0,"_row":40},{"data":"point_data","x":5.1,"y":1,"_row":41},{"data":"point_data","x":5.2,"y":0,"_row":42},{"data":"point_data","x":5.2,"y":0,"_row":43},{"data":"point_data","x":5.2,"y":0,"_row":44},{"data":"point_data","x":5.2,"y":1,"_row":45},{"data":"point_data","x":5.3,"y":0,"_row":46},{"data":"point_data","x":5.4,"y":0,"_row":47},{"data":"point_data","x":5.4,"y":0,"_row":48},{"data":"point_data","x":5.4,"y":0,"_row":49},{"data":"point_data","x":5.4,"y":0,"_row":50},{"data":"point_data","x":5.4,"y":0,"_row":51},{"data":"point_data","x":5.4,"y":1,"_row":52},{"data":"point_data","x":5.5,"y":0,"_row":53},{"data":"point_data","x":5.5,"y":0,"_row":54},{"data":"point_data","x":5.5,"y":1,"_row":55},{"data":"point_data","x":5.5,"y":1,"_row":56},{"data":"point_data","x":5.5,"y":1,"_row":57},{"data":"point_data","x":5.5,"y":1,"_row":58},{"data":"point_data","x":5.5,"y":1,"_row":59},{"data":"point_data","x":5.6,"y":1,"_row":60},{"data":"point_data","x":5.6,"y":1,"_row":61},{"data":"point_data","x":5.6,"y":1,"_row":62},{"data":"point_data","x":5.6,"y":1,"_row":63},{"data":"point_data","x":5.6,"y":1,"_row":64},{"data":"point_data","x":5.6,"y":1,"_row":65},{"data":"point_data","x":5.7,"y":0,"_row":66},{"data":"point_data","x":5.7,"y":0,"_row":67},{"data":"point_data","x":5.7,"y":1,"_row":68},{"data":"point_data","x":5.7,"y":1,"_row":69},{"data":"point_data","x":5.7,"y":1,"_row":70},{"data":"point_data","x":5.7,"y":1,"_row":71},{"data":"point_data","x":5.7,"y":1,"_row":72},{"data":"point_data","x":5.7,"y":1,"_row":73},{"data":"point_data","x":5.8,"y":0,"_row":74},{"data":"point_data","x":5.8,"y":1,"_row":75},{"data":"point_data","x":5.8,"y":1,"_row":76},{"data":"point_data","x":5.8,"y":1,"_row":77},{"data":"point_data","x":5.8,"y":1,"_row":78},{"data":"point_data","x":5.8,"y":1,"_row":79},{"data":"point_data","x":5.8,"y":1,"_row":80},{"data":"point_data","x":5.9,"y":1,"_row":81},{"data":"point_data","x":5.9,"y":1,"_row":82},{"data":"point_data","x":5.9,"y":1,"_row":83},{"data":"point_data","x":6,"y":1,"_row":84},{"data":"point_data","x":6,"y":1,"_row":85},{"data":"point_data","x":6,"y":1,"_row":86},{"data":"point_data","x":6,"y":1,"_row":87},{"data":"point_data","x":6,"y":1,"_row":88},{"data":"point_data","x":6,"y":1,"_row":89},{"data":"point_data","x":6.1,"y":1,"_row":90},{"data":"point_data","x":6.1,"y":1,"_row":91},{"data":"point_data","x":6.1,"y":1,"_row":92},{"data":"point_data","x":6.1,"y":1,"_row":93},{"data":"point_data","x":6.1,"y":1,"_row":94},{"data":"point_data","x":6.1,"y":1,"_row":95},{"data":"point_data","x":6.2,"y":1,"_row":96},{"data":"point_data","x":6.2,"y":1,"_row":97},{"data":"point_data","x":6.2,"y":1,"_row":98},{"data":"point_data","x":6.2,"y":1,"_row":99},{"data":"point_data","x":6.3,"y":1,"_row":100},{"data":"point_data","x":6.3,"y":1,"_row":101},{"data":"point_data","x":6.3,"y":1,"_row":102},{"data":"point_data","x":6.3,"y":1,"_row":103},{"data":"point_data","x":6.3,"y":1,"_row":104},{"data":"point_data","x":6.3,"y":1,"_row":105},{"data":"point_data","x":6.3,"y":1,"_row":106},{"data":"point_data","x":6.3,"y":1,"_row":107},{"data":"point_data","x":6.3,"y":1,"_row":108},{"data":"point_data","x":6.4,"y":1,"_row":109},{"data":"point_data","x":6.4,"y":1,"_row":110},{"data":"point_data","x":6.4,"y":1,"_row":111},{"data":"point_data","x":6.4,"y":1,"_row":112},{"data":"point_data","x":6.4,"y":1,"_row":113},{"data":"point_data","x":6.4,"y":1,"_row":114},{"data":"point_data","x":6.4,"y":1,"_row":115},{"data":"point_data","x":6.5,"y":1,"_row":116},{"data":"point_data","x":6.5,"y":1,"_row":117},{"data":"point_data","x":6.5,"y":1,"_row":118},{"data":"point_data","x":6.5,"y":1,"_row":119},{"data":"point_data","x":6.5,"y":1,"_row":120},{"data":"point_data","x":6.6,"y":1,"_row":121},{"data":"point_data","x":6.6,"y":1,"_row":122},{"data":"point_data","x":6.7,"y":1,"_row":123},{"data":"point_data","x":6.7,"y":1,"_row":124},{"data":"point_data","x":6.7,"y":1,"_row":125},{"data":"point_data","x":6.7,"y":1,"_row":126},{"data":"point_data","x":6.7,"y":1,"_row":127},{"data":"point_data","x":6.7,"y":1,"_row":128},{"data":"point_data","x":6.7,"y":1,"_row":129},{"data":"point_data","x":6.7,"y":1,"_row":130},{"data":"point_data","x":6.8,"y":1,"_row":131},{"data":"point_data","x":6.8,"y":1,"_row":132},{"data":"point_data","x":6.8,"y":1,"_row":133},{"data":"point_data","x":6.9,"y":1,"_row":134},{"data":"point_data","x":6.9,"y":1,"_row":135},{"data":"point_data","x":6.9,"y":1,"_row":136},{"data":"point_data","x":6.9,"y":1,"_row":137},{"data":"point_data","x":7,"y":1,"_row":138},{"data":"point_data","x":7.1,"y":1,"_row":139},{"data":"point_data","x":7.2,"y":1,"_row":140},{"data":"point_data","x":7.2,"y":1,"_row":141},{"data":"point_data","x":7.2,"y":1,"_row":142},{"data":"point_data","x":7.3,"y":1,"_row":143},{"data":"point_data","x":7.4,"y":1,"_row":144},{"data":"point_data","x":7.6,"y":1,"_row":145},{"data":"point_data","x":7.7,"y":1,"_row":146},{"data":"point_data","x":7.7,"y":1,"_row":147},{"data":"point_data","x":7.7,"y":1,"_row":148},{"data":"point_data","x":7.7,"y":1,"_row":149},{"data":"point_data","x":7.9,"y":1,"_row":150}]},"type":"json","container":"svg","options":{"draw_start":4.300000000000001,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1.2,"pin_start":true,"x_range":[4.3,7.9],"x_by":0,"x_lab":"","y_range":[-0.05,1.05],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Probability of 'Setosa' Species Based on Sepal Length","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>Here’s another chance for you to test your data drawing skills! Try
to draw the logistic regression curve showing the probability of an iris
being of ‘Setosa’ species based on its sepal length.</p>
</div>
<div class="section level3">
<h3 id="polynomial-regression">Polynomial Regression<a class="anchor" aria-label="anchor" href="#polynomial-regression"></a>
</h3>
<p>Polynomial regression can be used to model relationships between
variables that aren’t linear. In this case, we’ll generate a second
degree polynomial regression using “Petal.Length” as the x variable, and
“Sepal.Length” as the y variable.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Generate custom data for polynomial regression</span></span>
<span><span class="va">custom_data_poly</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">iris</span>,</span>
<span>  xvar <span class="op">=</span> <span class="st">"Petal.Length"</span>,</span>
<span>  yvar <span class="op">=</span> <span class="st">"Sepal.Length"</span>,</span>
<span>  regression_type <span class="op">=</span> <span class="st">"polynomial"</span>,</span>
<span>  degree <span class="op">=</span> <span class="fl">2</span> <span class="co"># default is 2 if not specified for poly regression</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In this example, we used a degree of 2, which means that we are
fitting a quadratic polynomial to the data. Higher degrees will fit more
complex polynomial curves, but remember to be aware that higher-degree
polynomials can lead to over fitting.</p>
<p>Let’s visualize this data using the <code><a href="../reference/drawr.html">drawr()</a></code>
function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data_poly</span>, </span>
<span>      title <span class="op">=</span> <span class="st">"Sepal Length vs Petal Length: Poly Regression"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-0153b5d5bb993e0658de" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-0153b5d5bb993e0658de">{"x":{"data":{"line_data":[{"data":"line_data","x":1,"y":4.9754,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":1},{"data":"line_data","x":1.1,"y":4.9761,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":2},{"data":"line_data","x":1.2,"y":4.9784,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":3},{"data":"line_data","x":1.2,"y":4.9784,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":4},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":5},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":6},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":7},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":8},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":9},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":10},{"data":"line_data","x":1.3,"y":4.9823,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":11},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":12},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":13},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":14},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":15},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":16},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":17},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":18},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":19},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":20},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":21},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":22},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":23},{"data":"line_data","x":1.4,"y":4.9879,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":24},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":25},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":26},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":27},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":28},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":29},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":30},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":31},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":32},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":33},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":34},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":35},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":36},{"data":"line_data","x":1.5,"y":4.9951,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":37},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":38},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":39},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":40},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":41},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":42},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":43},{"data":"line_data","x":1.6,"y":5.0039,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":44},{"data":"line_data","x":1.7,"y":5.0144,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":45},{"data":"line_data","x":1.7,"y":5.0144,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":46},{"data":"line_data","x":1.7,"y":5.0144,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":47},{"data":"line_data","x":1.7,"y":5.0144,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":48},{"data":"line_data","x":1.9,"y":5.0401,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":49},{"data":"line_data","x":1.9,"y":5.0401,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":50},{"data":"line_data","x":3,"y":5.2984,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":51},{"data":"line_data","x":3.3,"y":5.4031,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":52},{"data":"line_data","x":3.3,"y":5.4031,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":53},{"data":"line_data","x":3.5,"y":5.481,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":54},{"data":"line_data","x":3.5,"y":5.481,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":55},{"data":"line_data","x":3.6,"y":5.5224,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":56},{"data":"line_data","x":3.7,"y":5.5655,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":57},{"data":"line_data","x":3.8,"y":5.6101,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":58},{"data":"line_data","x":3.9,"y":5.6564,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":59},{"data":"line_data","x":3.9,"y":5.6564,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":60},{"data":"line_data","x":3.9,"y":5.6564,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":61},{"data":"line_data","x":4,"y":5.7043,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":62},{"data":"line_data","x":4,"y":5.7043,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":63},{"data":"line_data","x":4,"y":5.7043,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":64},{"data":"line_data","x":4,"y":5.7043,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":65},{"data":"line_data","x":4,"y":5.7043,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":66},{"data":"line_data","x":4.1,"y":5.7539,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":67},{"data":"line_data","x":4.1,"y":5.7539,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":68},{"data":"line_data","x":4.1,"y":5.7539,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":69},{"data":"line_data","x":4.2,"y":5.8051,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":70},{"data":"line_data","x":4.2,"y":5.8051,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":71},{"data":"line_data","x":4.2,"y":5.8051,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":72},{"data":"line_data","x":4.2,"y":5.8051,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":73},{"data":"line_data","x":4.3,"y":5.8579,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":74},{"data":"line_data","x":4.3,"y":5.8579,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":75},{"data":"line_data","x":4.4,"y":5.9123,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":76},{"data":"line_data","x":4.4,"y":5.9123,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":77},{"data":"line_data","x":4.4,"y":5.9123,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":78},{"data":"line_data","x":4.4,"y":5.9123,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":79},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":80},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":81},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":82},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":83},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":84},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":85},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":86},{"data":"line_data","x":4.5,"y":5.9684,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":87},{"data":"line_data","x":4.6,"y":6.0261,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":88},{"data":"line_data","x":4.6,"y":6.0261,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":89},{"data":"line_data","x":4.6,"y":6.0261,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":90},{"data":"line_data","x":4.7,"y":6.0854,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":91},{"data":"line_data","x":4.7,"y":6.0854,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":92},{"data":"line_data","x":4.7,"y":6.0854,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":93},{"data":"line_data","x":4.7,"y":6.0854,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":94},{"data":"line_data","x":4.7,"y":6.0854,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":95},{"data":"line_data","x":4.8,"y":6.1464,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":96},{"data":"line_data","x":4.8,"y":6.1464,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":97},{"data":"line_data","x":4.8,"y":6.1464,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":98},{"data":"line_data","x":4.8,"y":6.1464,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":99},{"data":"line_data","x":4.9,"y":6.2089,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":100},{"data":"line_data","x":4.9,"y":6.2089,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":101},{"data":"line_data","x":4.9,"y":6.2089,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":102},{"data":"line_data","x":4.9,"y":6.2089,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":103},{"data":"line_data","x":4.9,"y":6.2089,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":104},{"data":"line_data","x":5,"y":6.2731,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":105},{"data":"line_data","x":5,"y":6.2731,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":106},{"data":"line_data","x":5,"y":6.2731,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":107},{"data":"line_data","x":5,"y":6.2731,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":108},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":109},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":110},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":111},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":112},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":113},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":114},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":115},{"data":"line_data","x":5.1,"y":6.339,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":116},{"data":"line_data","x":5.2,"y":6.4065,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":117},{"data":"line_data","x":5.2,"y":6.4065,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":118},{"data":"line_data","x":5.3,"y":6.4756,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":119},{"data":"line_data","x":5.3,"y":6.4756,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":120},{"data":"line_data","x":5.4,"y":6.5463,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":121},{"data":"line_data","x":5.4,"y":6.5463,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":122},{"data":"line_data","x":5.5,"y":6.6187,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":123},{"data":"line_data","x":5.5,"y":6.6187,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":124},{"data":"line_data","x":5.5,"y":6.6187,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":125},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":126},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":127},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":128},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":129},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":130},{"data":"line_data","x":5.6,"y":6.6926,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":131},{"data":"line_data","x":5.7,"y":6.7683,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":132},{"data":"line_data","x":5.7,"y":6.7683,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":133},{"data":"line_data","x":5.7,"y":6.7683,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":134},{"data":"line_data","x":5.8,"y":6.8455,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":135},{"data":"line_data","x":5.8,"y":6.8455,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":136},{"data":"line_data","x":5.8,"y":6.8455,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":137},{"data":"line_data","x":5.9,"y":6.9244,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":138},{"data":"line_data","x":5.9,"y":6.9244,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":139},{"data":"line_data","x":6,"y":7.0049,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":140},{"data":"line_data","x":6,"y":7.0049,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":141},{"data":"line_data","x":6.1,"y":7.087,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":142},{"data":"line_data","x":6.1,"y":7.087,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":143},{"data":"line_data","x":6.1,"y":7.087,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":144},{"data":"line_data","x":6.3,"y":7.2562,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":145},{"data":"line_data","x":6.4,"y":7.3432,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":146},{"data":"line_data","x":6.6,"y":7.5221,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":147},{"data":"line_data","x":6.7,"y":7.6141,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":148},{"data":"line_data","x":6.7,"y":7.6141,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":149},{"data":"line_data","x":6.9,"y":7.8028,"coef":"-0.164350725837141, 0.0814630221452665","int":5.0583,"_row":150}],"point_data":[{"data":"point_data","x":1,"y":4.6,"_row":1},{"data":"point_data","x":1.1,"y":4.3,"_row":2},{"data":"point_data","x":1.2,"y":5.8,"_row":3},{"data":"point_data","x":1.2,"y":5,"_row":4},{"data":"point_data","x":1.3,"y":4.7,"_row":5},{"data":"point_data","x":1.3,"y":5.4,"_row":6},{"data":"point_data","x":1.3,"y":5.5,"_row":7},{"data":"point_data","x":1.3,"y":4.4,"_row":8},{"data":"point_data","x":1.3,"y":5,"_row":9},{"data":"point_data","x":1.3,"y":4.5,"_row":10},{"data":"point_data","x":1.3,"y":4.4,"_row":11},{"data":"point_data","x":1.4,"y":5.1,"_row":12},{"data":"point_data","x":1.4,"y":4.9,"_row":13},{"data":"point_data","x":1.4,"y":5,"_row":14},{"data":"point_data","x":1.4,"y":4.6,"_row":15},{"data":"point_data","x":1.4,"y":4.4,"_row":16},{"data":"point_data","x":1.4,"y":4.8,"_row":17},{"data":"point_data","x":1.4,"y":5.1,"_row":18},{"data":"point_data","x":1.4,"y":5.2,"_row":19},{"data":"point_data","x":1.4,"y":5.5,"_row":20},{"data":"point_data","x":1.4,"y":4.9,"_row":21},{"data":"point_data","x":1.4,"y":4.8,"_row":22},{"data":"point_data","x":1.4,"y":4.6,"_row":23},{"data":"point_data","x":1.4,"y":5,"_row":24},{"data":"point_data","x":1.5,"y":4.6,"_row":25},{"data":"point_data","x":1.5,"y":5,"_row":26},{"data":"point_data","x":1.5,"y":4.9,"_row":27},{"data":"point_data","x":1.5,"y":5.4,"_row":28},{"data":"point_data","x":1.5,"y":5.7,"_row":29},{"data":"point_data","x":1.5,"y":5.1,"_row":30},{"data":"point_data","x":1.5,"y":5.1,"_row":31},{"data":"point_data","x":1.5,"y":5.2,"_row":32},{"data":"point_data","x":1.5,"y":5.4,"_row":33},{"data":"point_data","x":1.5,"y":5.2,"_row":34},{"data":"point_data","x":1.5,"y":4.9,"_row":35},{"data":"point_data","x":1.5,"y":5.1,"_row":36},{"data":"point_data","x":1.5,"y":5.3,"_row":37},{"data":"point_data","x":1.6,"y":4.8,"_row":38},{"data":"point_data","x":1.6,"y":5,"_row":39},{"data":"point_data","x":1.6,"y":5,"_row":40},{"data":"point_data","x":1.6,"y":4.7,"_row":41},{"data":"point_data","x":1.6,"y":4.8,"_row":42},{"data":"point_data","x":1.6,"y":5,"_row":43},{"data":"point_data","x":1.6,"y":5.1,"_row":44},{"data":"point_data","x":1.7,"y":5.4,"_row":45},{"data":"point_data","x":1.7,"y":5.7,"_row":46},{"data":"point_data","x":1.7,"y":5.4,"_row":47},{"data":"point_data","x":1.7,"y":5.1,"_row":48},{"data":"point_data","x":1.9,"y":4.8,"_row":49},{"data":"point_data","x":1.9,"y":5.1,"_row":50},{"data":"point_data","x":3,"y":5.1,"_row":51},{"data":"point_data","x":3.3,"y":4.9,"_row":52},{"data":"point_data","x":3.3,"y":5,"_row":53},{"data":"point_data","x":3.5,"y":5,"_row":54},{"data":"point_data","x":3.5,"y":5.7,"_row":55},{"data":"point_data","x":3.6,"y":5.6,"_row":56},{"data":"point_data","x":3.7,"y":5.5,"_row":57},{"data":"point_data","x":3.8,"y":5.5,"_row":58},{"data":"point_data","x":3.9,"y":5.2,"_row":59},{"data":"point_data","x":3.9,"y":5.6,"_row":60},{"data":"point_data","x":3.9,"y":5.8,"_row":61},{"data":"point_data","x":4,"y":5.5,"_row":62},{"data":"point_data","x":4,"y":6,"_row":63},{"data":"point_data","x":4,"y":6.1,"_row":64},{"data":"point_data","x":4,"y":5.5,"_row":65},{"data":"point_data","x":4,"y":5.8,"_row":66},{"data":"point_data","x":4.1,"y":5.8,"_row":67},{"data":"point_data","x":4.1,"y":5.6,"_row":68},{"data":"point_data","x":4.1,"y":5.7,"_row":69},{"data":"point_data","x":4.2,"y":5.9,"_row":70},{"data":"point_data","x":4.2,"y":5.6,"_row":71},{"data":"point_data","x":4.2,"y":5.7,"_row":72},{"data":"point_data","x":4.2,"y":5.7,"_row":73},{"data":"point_data","x":4.3,"y":6.4,"_row":74},{"data":"point_data","x":4.3,"y":6.2,"_row":75},{"data":"point_data","x":4.4,"y":6.7,"_row":76},{"data":"point_data","x":4.4,"y":6.6,"_row":77},{"data":"point_data","x":4.4,"y":6.3,"_row":78},{"data":"point_data","x":4.4,"y":5.5,"_row":79},{"data":"point_data","x":4.5,"y":6.4,"_row":80},{"data":"point_data","x":4.5,"y":5.7,"_row":81},{"data":"point_data","x":4.5,"y":5.6,"_row":82},{"data":"point_data","x":4.5,"y":6.2,"_row":83},{"data":"point_data","x":4.5,"y":6,"_row":84},{"data":"point_data","x":4.5,"y":5.4,"_row":85},{"data":"point_data","x":4.5,"y":6,"_row":86},{"data":"point_data","x":4.5,"y":4.9,"_row":87},{"data":"point_data","x":4.6,"y":6.5,"_row":88},{"data":"point_data","x":4.6,"y":6.6,"_row":89},{"data":"point_data","x":4.6,"y":6.1,"_row":90},{"data":"point_data","x":4.7,"y":7,"_row":91},{"data":"point_data","x":4.7,"y":6.3,"_row":92},{"data":"point_data","x":4.7,"y":6.1,"_row":93},{"data":"point_data","x":4.7,"y":6.1,"_row":94},{"data":"point_data","x":4.7,"y":6.7,"_row":95},{"data":"point_data","x":4.8,"y":5.9,"_row":96},{"data":"point_data","x":4.8,"y":6.8,"_row":97},{"data":"point_data","x":4.8,"y":6.2,"_row":98},{"data":"point_data","x":4.8,"y":6,"_row":99},{"data":"point_data","x":4.9,"y":6.9,"_row":100},{"data":"point_data","x":4.9,"y":6.3,"_row":101},{"data":"point_data","x":4.9,"y":5.6,"_row":102},{"data":"point_data","x":4.9,"y":6.3,"_row":103},{"data":"point_data","x":4.9,"y":6.1,"_row":104},{"data":"point_data","x":5,"y":6.7,"_row":105},{"data":"point_data","x":5,"y":5.7,"_row":106},{"data":"point_data","x":5,"y":6,"_row":107},{"data":"point_data","x":5,"y":6.3,"_row":108},{"data":"point_data","x":5.1,"y":6,"_row":109},{"data":"point_data","x":5.1,"y":5.8,"_row":110},{"data":"point_data","x":5.1,"y":6.5,"_row":111},{"data":"point_data","x":5.1,"y":5.8,"_row":112},{"data":"point_data","x":5.1,"y":6.3,"_row":113},{"data":"point_data","x":5.1,"y":6.9,"_row":114},{"data":"point_data","x":5.1,"y":5.8,"_row":115},{"data":"point_data","x":5.1,"y":5.9,"_row":116},{"data":"point_data","x":5.2,"y":6.7,"_row":117},{"data":"point_data","x":5.2,"y":6.5,"_row":118},{"data":"point_data","x":5.3,"y":6.4,"_row":119},{"data":"point_data","x":5.3,"y":6.4,"_row":120},{"data":"point_data","x":5.4,"y":6.9,"_row":121},{"data":"point_data","x":5.4,"y":6.2,"_row":122},{"data":"point_data","x":5.5,"y":6.8,"_row":123},{"data":"point_data","x":5.5,"y":6.5,"_row":124},{"data":"point_data","x":5.5,"y":6.4,"_row":125},{"data":"point_data","x":5.6,"y":6.3,"_row":126},{"data":"point_data","x":5.6,"y":6.4,"_row":127},{"data":"point_data","x":5.6,"y":6.4,"_row":128},{"data":"point_data","x":5.6,"y":6.1,"_row":129},{"data":"point_data","x":5.6,"y":6.3,"_row":130},{"data":"point_data","x":5.6,"y":6.7,"_row":131},{"data":"point_data","x":5.7,"y":6.9,"_row":132},{"data":"point_data","x":5.7,"y":6.7,"_row":133},{"data":"point_data","x":5.7,"y":6.7,"_row":134},{"data":"point_data","x":5.8,"y":6.5,"_row":135},{"data":"point_data","x":5.8,"y":6.7,"_row":136},{"data":"point_data","x":5.8,"y":7.2,"_row":137},{"data":"point_data","x":5.9,"y":7.1,"_row":138},{"data":"point_data","x":5.9,"y":6.8,"_row":139},{"data":"point_data","x":6,"y":6.3,"_row":140},{"data":"point_data","x":6,"y":7.2,"_row":141},{"data":"point_data","x":6.1,"y":7.2,"_row":142},{"data":"point_data","x":6.1,"y":7.4,"_row":143},{"data":"point_data","x":6.1,"y":7.7,"_row":144},{"data":"point_data","x":6.3,"y":7.3,"_row":145},{"data":"point_data","x":6.4,"y":7.9,"_row":146},{"data":"point_data","x":6.6,"y":7.6,"_row":147},{"data":"point_data","x":6.7,"y":7.7,"_row":148},{"data":"point_data","x":6.7,"y":7.7,"_row":149},{"data":"point_data","x":6.9,"y":7.7,"_row":150}]},"type":"json","container":"svg","options":{"draw_start":1,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[1,6.9],"x_by":0,"x_lab":"","y_range":[4.12,8.08],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Sepal Length vs Petal Length: Poly Regression","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>Go ahead, try to draw the polynomial regression curve showing the
relationship between petal length and sepal length. This may be more
challenging than the previous plots as the relationship is not
linear!</p>
</div>
<div class="section level3">
<h3 id="loess-regression">Loess Regression<a class="anchor" aria-label="anchor" href="#loess-regression"></a>
</h3>
<p>Loess regression is a non-parametric method that uses local data
fitting to fit a smooth curve through points in a scatter plot. We’ll
generate a loess regression using “Sepal.Length” as the x variable, and
“Sepal.Width” as the y variable.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Generate custom data for loess regression</span></span>
<span><span class="va">custom_data_loess</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">iris</span>,</span>
<span>  xvar <span class="op">=</span> <span class="st">"Petal.Width"</span>,</span>
<span>  yvar <span class="op">=</span> <span class="st">"Sepal.Width"</span>,</span>
<span>  regression_type <span class="op">=</span> <span class="st">"loess"</span>,</span>
<span>  degree <span class="op">=</span> <span class="fl">1</span>, <span class="co"># default if not specified is 1 for loess regression (must be 0, 1, or 2)</span></span>
<span>  span <span class="op">=</span> <span class="fl">0.75</span> <span class="co"># default if not specified is 0.75 (ranges between 0 and 1)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In this example, we used a span of 0.75, which determines the amount
of data considered for each local fit. Adjusting the span parameter
allows you to control the flexibility of the loess fit. Too large of a
span will result in the regression being over-smoothed, resulting in
bias and loss of information, while too small of a span with
insufficient data can result in larger variance and over fitting. For
more details on selecting the optimal smoothing parameter, you can refer
to this <a href="http://r-statistics.co/Loess-Regression-With-R.html" class="external-link">guide</a>.</p>
<p>The degree parameter determines the degree of the polynomials used
for the local fitting. A degree of 1 fits straight lines, while a degree
of 2 fits parabolas. Using a higher degree can capture more complex
patterns, but be careful not to over fit. Using a degree of 0 will turn
loess into a weighted moving average.</p>
<p>Now we can visualize this data:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data_loess</span>,</span>
<span>      title <span class="op">=</span> <span class="st">"Sepal Width vs Petal Width: Loess Regression"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-769253c876c5613a424f" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-769253c876c5613a424f">{"x":{"data":{"line_data":[{"data":"line_data","x":0.1,"y":3.4948,"_row":1},{"data":"line_data","x":0.1,"y":3.4948,"_row":2},{"data":"line_data","x":0.1,"y":3.4948,"_row":3},{"data":"line_data","x":0.1,"y":3.4948,"_row":4},{"data":"line_data","x":0.1,"y":3.4948,"_row":5},{"data":"line_data","x":0.2,"y":3.425,"_row":6},{"data":"line_data","x":0.2,"y":3.425,"_row":7},{"data":"line_data","x":0.2,"y":3.425,"_row":8},{"data":"line_data","x":0.2,"y":3.425,"_row":9},{"data":"line_data","x":0.2,"y":3.425,"_row":10},{"data":"line_data","x":0.2,"y":3.425,"_row":11},{"data":"line_data","x":0.2,"y":3.425,"_row":12},{"data":"line_data","x":0.2,"y":3.425,"_row":13},{"data":"line_data","x":0.2,"y":3.425,"_row":14},{"data":"line_data","x":0.2,"y":3.425,"_row":15},{"data":"line_data","x":0.2,"y":3.425,"_row":16},{"data":"line_data","x":0.2,"y":3.425,"_row":17},{"data":"line_data","x":0.2,"y":3.425,"_row":18},{"data":"line_data","x":0.2,"y":3.425,"_row":19},{"data":"line_data","x":0.2,"y":3.425,"_row":20},{"data":"line_data","x":0.2,"y":3.425,"_row":21},{"data":"line_data","x":0.2,"y":3.425,"_row":22},{"data":"line_data","x":0.2,"y":3.425,"_row":23},{"data":"line_data","x":0.2,"y":3.425,"_row":24},{"data":"line_data","x":0.2,"y":3.425,"_row":25},{"data":"line_data","x":0.2,"y":3.425,"_row":26},{"data":"line_data","x":0.2,"y":3.425,"_row":27},{"data":"line_data","x":0.2,"y":3.425,"_row":28},{"data":"line_data","x":0.2,"y":3.425,"_row":29},{"data":"line_data","x":0.2,"y":3.425,"_row":30},{"data":"line_data","x":0.2,"y":3.425,"_row":31},{"data":"line_data","x":0.2,"y":3.425,"_row":32},{"data":"line_data","x":0.2,"y":3.425,"_row":33},{"data":"line_data","x":0.2,"y":3.425,"_row":34},{"data":"line_data","x":0.3,"y":3.3552,"_row":35},{"data":"line_data","x":0.3,"y":3.3552,"_row":36},{"data":"line_data","x":0.3,"y":3.3552,"_row":37},{"data":"line_data","x":0.3,"y":3.3552,"_row":38},{"data":"line_data","x":0.3,"y":3.3552,"_row":39},{"data":"line_data","x":0.3,"y":3.3552,"_row":40},{"data":"line_data","x":0.3,"y":3.3552,"_row":41},{"data":"line_data","x":0.4,"y":3.2772,"_row":42},{"data":"line_data","x":0.4,"y":3.2772,"_row":43},{"data":"line_data","x":0.4,"y":3.2772,"_row":44},{"data":"line_data","x":0.4,"y":3.2772,"_row":45},{"data":"line_data","x":0.4,"y":3.2772,"_row":46},{"data":"line_data","x":0.4,"y":3.2772,"_row":47},{"data":"line_data","x":0.4,"y":3.2772,"_row":48},{"data":"line_data","x":0.5,"y":3.1853,"_row":49},{"data":"line_data","x":0.6,"y":3.0871,"_row":50},{"data":"line_data","x":1,"y":2.7828,"_row":51},{"data":"line_data","x":1,"y":2.7828,"_row":52},{"data":"line_data","x":1,"y":2.7828,"_row":53},{"data":"line_data","x":1,"y":2.7828,"_row":54},{"data":"line_data","x":1,"y":2.7828,"_row":55},{"data":"line_data","x":1,"y":2.7828,"_row":56},{"data":"line_data","x":1,"y":2.7828,"_row":57},{"data":"line_data","x":1.1,"y":2.7669,"_row":58},{"data":"line_data","x":1.1,"y":2.7669,"_row":59},{"data":"line_data","x":1.1,"y":2.7669,"_row":60},{"data":"line_data","x":1.2,"y":2.7632,"_row":61},{"data":"line_data","x":1.2,"y":2.7632,"_row":62},{"data":"line_data","x":1.2,"y":2.7632,"_row":63},{"data":"line_data","x":1.2,"y":2.7632,"_row":64},{"data":"line_data","x":1.2,"y":2.7632,"_row":65},{"data":"line_data","x":1.3,"y":2.7702,"_row":66},{"data":"line_data","x":1.3,"y":2.7702,"_row":67},{"data":"line_data","x":1.3,"y":2.7702,"_row":68},{"data":"line_data","x":1.3,"y":2.7702,"_row":69},{"data":"line_data","x":1.3,"y":2.7702,"_row":70},{"data":"line_data","x":1.3,"y":2.7702,"_row":71},{"data":"line_data","x":1.3,"y":2.7702,"_row":72},{"data":"line_data","x":1.3,"y":2.7702,"_row":73},{"data":"line_data","x":1.3,"y":2.7702,"_row":74},{"data":"line_data","x":1.3,"y":2.7702,"_row":75},{"data":"line_data","x":1.3,"y":2.7702,"_row":76},{"data":"line_data","x":1.3,"y":2.7702,"_row":77},{"data":"line_data","x":1.3,"y":2.7702,"_row":78},{"data":"line_data","x":1.4,"y":2.7858,"_row":79},{"data":"line_data","x":1.4,"y":2.7858,"_row":80},{"data":"line_data","x":1.4,"y":2.7858,"_row":81},{"data":"line_data","x":1.4,"y":2.7858,"_row":82},{"data":"line_data","x":1.4,"y":2.7858,"_row":83},{"data":"line_data","x":1.4,"y":2.7858,"_row":84},{"data":"line_data","x":1.4,"y":2.7858,"_row":85},{"data":"line_data","x":1.4,"y":2.7858,"_row":86},{"data":"line_data","x":1.5,"y":2.8087,"_row":87},{"data":"line_data","x":1.5,"y":2.8087,"_row":88},{"data":"line_data","x":1.5,"y":2.8087,"_row":89},{"data":"line_data","x":1.5,"y":2.8087,"_row":90},{"data":"line_data","x":1.5,"y":2.8087,"_row":91},{"data":"line_data","x":1.5,"y":2.8087,"_row":92},{"data":"line_data","x":1.5,"y":2.8087,"_row":93},{"data":"line_data","x":1.5,"y":2.8087,"_row":94},{"data":"line_data","x":1.5,"y":2.8087,"_row":95},{"data":"line_data","x":1.5,"y":2.8087,"_row":96},{"data":"line_data","x":1.5,"y":2.8087,"_row":97},{"data":"line_data","x":1.5,"y":2.8087,"_row":98},{"data":"line_data","x":1.6,"y":2.8482,"_row":99},{"data":"line_data","x":1.6,"y":2.8482,"_row":100},{"data":"line_data","x":1.6,"y":2.8482,"_row":101},{"data":"line_data","x":1.6,"y":2.8482,"_row":102},{"data":"line_data","x":1.7,"y":2.8888,"_row":103},{"data":"line_data","x":1.7,"y":2.8888,"_row":104},{"data":"line_data","x":1.8,"y":2.9291,"_row":105},{"data":"line_data","x":1.8,"y":2.9291,"_row":106},{"data":"line_data","x":1.8,"y":2.9291,"_row":107},{"data":"line_data","x":1.8,"y":2.9291,"_row":108},{"data":"line_data","x":1.8,"y":2.9291,"_row":109},{"data":"line_data","x":1.8,"y":2.9291,"_row":110},{"data":"line_data","x":1.8,"y":2.9291,"_row":111},{"data":"line_data","x":1.8,"y":2.9291,"_row":112},{"data":"line_data","x":1.8,"y":2.9291,"_row":113},{"data":"line_data","x":1.8,"y":2.9291,"_row":114},{"data":"line_data","x":1.8,"y":2.9291,"_row":115},{"data":"line_data","x":1.8,"y":2.9291,"_row":116},{"data":"line_data","x":1.9,"y":2.9692,"_row":117},{"data":"line_data","x":1.9,"y":2.9692,"_row":118},{"data":"line_data","x":1.9,"y":2.9692,"_row":119},{"data":"line_data","x":1.9,"y":2.9692,"_row":120},{"data":"line_data","x":1.9,"y":2.9692,"_row":121},{"data":"line_data","x":2,"y":3.0097,"_row":122},{"data":"line_data","x":2,"y":3.0097,"_row":123},{"data":"line_data","x":2,"y":3.0097,"_row":124},{"data":"line_data","x":2,"y":3.0097,"_row":125},{"data":"line_data","x":2,"y":3.0097,"_row":126},{"data":"line_data","x":2,"y":3.0097,"_row":127},{"data":"line_data","x":2.1,"y":3.0498,"_row":128},{"data":"line_data","x":2.1,"y":3.0498,"_row":129},{"data":"line_data","x":2.1,"y":3.0498,"_row":130},{"data":"line_data","x":2.1,"y":3.0498,"_row":131},{"data":"line_data","x":2.1,"y":3.0498,"_row":132},{"data":"line_data","x":2.1,"y":3.0498,"_row":133},{"data":"line_data","x":2.2,"y":3.0895,"_row":134},{"data":"line_data","x":2.2,"y":3.0895,"_row":135},{"data":"line_data","x":2.2,"y":3.0895,"_row":136},{"data":"line_data","x":2.3,"y":3.1289,"_row":137},{"data":"line_data","x":2.3,"y":3.1289,"_row":138},{"data":"line_data","x":2.3,"y":3.1289,"_row":139},{"data":"line_data","x":2.3,"y":3.1289,"_row":140},{"data":"line_data","x":2.3,"y":3.1289,"_row":141},{"data":"line_data","x":2.3,"y":3.1289,"_row":142},{"data":"line_data","x":2.3,"y":3.1289,"_row":143},{"data":"line_data","x":2.3,"y":3.1289,"_row":144},{"data":"line_data","x":2.4,"y":3.1682,"_row":145},{"data":"line_data","x":2.4,"y":3.1682,"_row":146},{"data":"line_data","x":2.4,"y":3.1682,"_row":147},{"data":"line_data","x":2.5,"y":3.2077,"_row":148},{"data":"line_data","x":2.5,"y":3.2077,"_row":149},{"data":"line_data","x":2.5,"y":3.2077,"_row":150}],"point_data":[{"data":"point_data","x":0.1,"y":3.1,"_row":1},{"data":"point_data","x":0.1,"y":3,"_row":2},{"data":"point_data","x":0.1,"y":3,"_row":3},{"data":"point_data","x":0.1,"y":4.1,"_row":4},{"data":"point_data","x":0.1,"y":3.6,"_row":5},{"data":"point_data","x":0.2,"y":3.5,"_row":6},{"data":"point_data","x":0.2,"y":3,"_row":7},{"data":"point_data","x":0.2,"y":3.2,"_row":8},{"data":"point_data","x":0.2,"y":3.1,"_row":9},{"data":"point_data","x":0.2,"y":3.6,"_row":10},{"data":"point_data","x":0.2,"y":3.4,"_row":11},{"data":"point_data","x":0.2,"y":2.9,"_row":12},{"data":"point_data","x":0.2,"y":3.7,"_row":13},{"data":"point_data","x":0.2,"y":3.4,"_row":14},{"data":"point_data","x":0.2,"y":4,"_row":15},{"data":"point_data","x":0.2,"y":3.4,"_row":16},{"data":"point_data","x":0.2,"y":3.6,"_row":17},{"data":"point_data","x":0.2,"y":3.4,"_row":18},{"data":"point_data","x":0.2,"y":3,"_row":19},{"data":"point_data","x":0.2,"y":3.5,"_row":20},{"data":"point_data","x":0.2,"y":3.4,"_row":21},{"data":"point_data","x":0.2,"y":3.2,"_row":22},{"data":"point_data","x":0.2,"y":3.1,"_row":23},{"data":"point_data","x":0.2,"y":4.2,"_row":24},{"data":"point_data","x":0.2,"y":3.1,"_row":25},{"data":"point_data","x":0.2,"y":3.2,"_row":26},{"data":"point_data","x":0.2,"y":3.5,"_row":27},{"data":"point_data","x":0.2,"y":3,"_row":28},{"data":"point_data","x":0.2,"y":3.4,"_row":29},{"data":"point_data","x":0.2,"y":3.2,"_row":30},{"data":"point_data","x":0.2,"y":3.8,"_row":31},{"data":"point_data","x":0.2,"y":3.2,"_row":32},{"data":"point_data","x":0.2,"y":3.7,"_row":33},{"data":"point_data","x":0.2,"y":3.3,"_row":34},{"data":"point_data","x":0.3,"y":3.4,"_row":35},{"data":"point_data","x":0.3,"y":3.5,"_row":36},{"data":"point_data","x":0.3,"y":3.8,"_row":37},{"data":"point_data","x":0.3,"y":3.8,"_row":38},{"data":"point_data","x":0.3,"y":3.5,"_row":39},{"data":"point_data","x":0.3,"y":2.3,"_row":40},{"data":"point_data","x":0.3,"y":3,"_row":41},{"data":"point_data","x":0.4,"y":3.9,"_row":42},{"data":"point_data","x":0.4,"y":4.4,"_row":43},{"data":"point_data","x":0.4,"y":3.9,"_row":44},{"data":"point_data","x":0.4,"y":3.7,"_row":45},{"data":"point_data","x":0.4,"y":3.4,"_row":46},{"data":"point_data","x":0.4,"y":3.4,"_row":47},{"data":"point_data","x":0.4,"y":3.8,"_row":48},{"data":"point_data","x":0.5,"y":3.3,"_row":49},{"data":"point_data","x":0.6,"y":3.5,"_row":50},{"data":"point_data","x":1,"y":2.4,"_row":51},{"data":"point_data","x":1,"y":2,"_row":52},{"data":"point_data","x":1,"y":2.2,"_row":53},{"data":"point_data","x":1,"y":2.7,"_row":54},{"data":"point_data","x":1,"y":2.6,"_row":55},{"data":"point_data","x":1,"y":2.4,"_row":56},{"data":"point_data","x":1,"y":2.3,"_row":57},{"data":"point_data","x":1.1,"y":2.5,"_row":58},{"data":"point_data","x":1.1,"y":2.4,"_row":59},{"data":"point_data","x":1.1,"y":2.5,"_row":60},{"data":"point_data","x":1.2,"y":2.8,"_row":61},{"data":"point_data","x":1.2,"y":2.7,"_row":62},{"data":"point_data","x":1.2,"y":2.6,"_row":63},{"data":"point_data","x":1.2,"y":2.6,"_row":64},{"data":"point_data","x":1.2,"y":3,"_row":65},{"data":"point_data","x":1.3,"y":2.3,"_row":66},{"data":"point_data","x":1.3,"y":2.8,"_row":67},{"data":"point_data","x":1.3,"y":2.9,"_row":68},{"data":"point_data","x":1.3,"y":2.9,"_row":69},{"data":"point_data","x":1.3,"y":2.8,"_row":70},{"data":"point_data","x":1.3,"y":2.9,"_row":71},{"data":"point_data","x":1.3,"y":2.3,"_row":72},{"data":"point_data","x":1.3,"y":3,"_row":73},{"data":"point_data","x":1.3,"y":2.5,"_row":74},{"data":"point_data","x":1.3,"y":2.7,"_row":75},{"data":"point_data","x":1.3,"y":2.9,"_row":76},{"data":"point_data","x":1.3,"y":2.9,"_row":77},{"data":"point_data","x":1.3,"y":2.8,"_row":78},{"data":"point_data","x":1.4,"y":3.2,"_row":79},{"data":"point_data","x":1.4,"y":2.7,"_row":80},{"data":"point_data","x":1.4,"y":2.9,"_row":81},{"data":"point_data","x":1.4,"y":3.1,"_row":82},{"data":"point_data","x":1.4,"y":3,"_row":83},{"data":"point_data","x":1.4,"y":2.8,"_row":84},{"data":"point_data","x":1.4,"y":3,"_row":85},{"data":"point_data","x":1.4,"y":2.6,"_row":86},{"data":"point_data","x":1.5,"y":3.2,"_row":87},{"data":"point_data","x":1.5,"y":3.1,"_row":88},{"data":"point_data","x":1.5,"y":2.8,"_row":89},{"data":"point_data","x":1.5,"y":3,"_row":90},{"data":"point_data","x":1.5,"y":3,"_row":91},{"data":"point_data","x":1.5,"y":2.2,"_row":92},{"data":"point_data","x":1.5,"y":2.5,"_row":93},{"data":"point_data","x":1.5,"y":2.9,"_row":94},{"data":"point_data","x":1.5,"y":3,"_row":95},{"data":"point_data","x":1.5,"y":3.1,"_row":96},{"data":"point_data","x":1.5,"y":2.2,"_row":97},{"data":"point_data","x":1.5,"y":2.8,"_row":98},{"data":"point_data","x":1.6,"y":3.3,"_row":99},{"data":"point_data","x":1.6,"y":2.7,"_row":100},{"data":"point_data","x":1.6,"y":3.4,"_row":101},{"data":"point_data","x":1.6,"y":3,"_row":102},{"data":"point_data","x":1.7,"y":3,"_row":103},{"data":"point_data","x":1.7,"y":2.5,"_row":104},{"data":"point_data","x":1.8,"y":3.2,"_row":105},{"data":"point_data","x":1.8,"y":2.9,"_row":106},{"data":"point_data","x":1.8,"y":2.9,"_row":107},{"data":"point_data","x":1.8,"y":2.5,"_row":108},{"data":"point_data","x":1.8,"y":3,"_row":109},{"data":"point_data","x":1.8,"y":2.7,"_row":110},{"data":"point_data","x":1.8,"y":3.2,"_row":111},{"data":"point_data","x":1.8,"y":2.8,"_row":112},{"data":"point_data","x":1.8,"y":3,"_row":113},{"data":"point_data","x":1.8,"y":3.1,"_row":114},{"data":"point_data","x":1.8,"y":3,"_row":115},{"data":"point_data","x":1.8,"y":3,"_row":116},{"data":"point_data","x":1.9,"y":2.7,"_row":117},{"data":"point_data","x":1.9,"y":2.7,"_row":118},{"data":"point_data","x":1.9,"y":2.8,"_row":119},{"data":"point_data","x":1.9,"y":2.7,"_row":120},{"data":"point_data","x":1.9,"y":2.5,"_row":121},{"data":"point_data","x":2,"y":3.2,"_row":122},{"data":"point_data","x":2,"y":2.5,"_row":123},{"data":"point_data","x":2,"y":2.8,"_row":124},{"data":"point_data","x":2,"y":2.8,"_row":125},{"data":"point_data","x":2,"y":3.8,"_row":126},{"data":"point_data","x":2,"y":3,"_row":127},{"data":"point_data","x":2.1,"y":3,"_row":128},{"data":"point_data","x":2.1,"y":3,"_row":129},{"data":"point_data","x":2.1,"y":3,"_row":130},{"data":"point_data","x":2.1,"y":3.3,"_row":131},{"data":"point_data","x":2.1,"y":2.8,"_row":132},{"data":"point_data","x":2.1,"y":3.1,"_row":133},{"data":"point_data","x":2.2,"y":3,"_row":134},{"data":"point_data","x":2.2,"y":3.8,"_row":135},{"data":"point_data","x":2.2,"y":2.8,"_row":136},{"data":"point_data","x":2.3,"y":3.2,"_row":137},{"data":"point_data","x":2.3,"y":2.6,"_row":138},{"data":"point_data","x":2.3,"y":3.2,"_row":139},{"data":"point_data","x":2.3,"y":3,"_row":140},{"data":"point_data","x":2.3,"y":3.1,"_row":141},{"data":"point_data","x":2.3,"y":3.2,"_row":142},{"data":"point_data","x":2.3,"y":3,"_row":143},{"data":"point_data","x":2.3,"y":3.4,"_row":144},{"data":"point_data","x":2.4,"y":2.8,"_row":145},{"data":"point_data","x":2.4,"y":3.4,"_row":146},{"data":"point_data","x":2.4,"y":3.1,"_row":147},{"data":"point_data","x":2.5,"y":3.3,"_row":148},{"data":"point_data","x":2.5,"y":3.6,"_row":149},{"data":"point_data","x":2.5,"y":3.3,"_row":150}]},"type":"json","container":"svg","options":{"draw_start":0.1,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0.1,2.5],"x_by":0,"x_lab":"","y_range":[1.88,4.52],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Sepal Width vs Petal Width: Loess Regression","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>Try to draw the loess regression curve. This might be the most
challenging plot yet, as the relationship between sepal width and sepal
length is complex and non-linear, you can almost imagine it as giving a
kid a crayon and telling them to draw a line through the points. Good
luck!</p>
</div>
</div>
<div class="section level2">
<h2 id="logarithmic-scale">Logarithmic Scale<a class="anchor" aria-label="anchor" href="#logarithmic-scale"></a>
</h2>
<p>The <code>youdrawitR</code> package offers functionality to plot data
on a logarithmic scale. This can be particularly useful when dealing
with data that exhibit exponential growth or decay. By transforming such
data onto a logarithmic scale, exponential trends can be made linear,
which can simplify the task of drawing the trend.</p>
<p>When using the <code><a href="../reference/customDataGen.html">customDataGen()</a></code> function, you can specify
log_y = TRUE to indicate that the y variable should be transformed to
the logarithmic scale. This will transform the fitted line as log(y) ~
x. If log_y is not specified or is FALSE, the fitted line is not
transformed. If using a log transformation remember that all y variable
data must be positive. Additionally, it is important to note that the
<code>youdrawitR</code> package currently only supports the log
transformation with the linear regression option.</p>
<p>In the <code><a href="../reference/drawr.html">drawr()</a></code> function, you can set the linear argument
to anything other than “true” to put the graph on a logarithmic scale.
You should do this whenever log_y = TRUE in
<code><a href="../reference/customDataGen.html">customDataGen()</a></code>. Also, you can specify the base of the
logarithm with the log_base argument. If log_base is not provided or is
NULL, a natural logarithm (base e) is used. Be sure to use the same
log_base value in both <code><a href="../reference/customDataGen.html">customDataGen()</a></code> and
<code><a href="../reference/drawr.html">drawr()</a></code> functions. In order to make the transformed fitted
line compatible with the logarithmic scale, the <code><a href="../reference/drawr.html">drawr()</a></code>
function exponentiates the y-values of the line data so the fitted line
is correctly adjusted to represent the linear trend on the logarithmic
scale.</p>
<p>Let’s see this feature in action:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Generate x-values</span></span>
<span><span class="va">x_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">100</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Generate y-values with exponential growth and some random noise</span></span>
<span><span class="va">y_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fl">0.05</span> <span class="op">*</span> <span class="va">x_values</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x_values</span><span class="op">)</span>, mean <span class="op">=</span> <span class="fl">1</span>, sd <span class="op">=</span> <span class="fl">0.2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Make sure all y-values are positive</span></span>
<span><span class="va">y_values</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">y_values</span> <span class="op">&lt;=</span> <span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">y_values</span><span class="op">)</span>, <span class="va">y_values</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Combine into a data frame</span></span>
<span><span class="va">exp_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="va">x_values</span>,</span>
<span>  y <span class="op">=</span> <span class="va">y_values</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Generate custom data for linear regression with log-transformed y</span></span>
<span><span class="va">custom_data_log</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">exp_data</span>,</span>
<span>  regression_type <span class="op">=</span> <span class="st">"linear"</span>, <span class="co"># must be linear for log_y to be TRUE</span></span>
<span>  log_y <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  log_base <span class="op">=</span> <span class="cn">NULL</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the data with a logarithmic y-scale</span></span>
<span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data_log</span>,</span>
<span>      linear <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>      log_base <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>      title <span class="op">=</span> <span class="st">"Log Scale"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-0e787149c2b40f85292d" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-0e787149c2b40f85292d">{"x":{"data":{"line_data":[{"data":"line_data","x":1,"y":1.0266,"coef":0.0505,"int":-0.0243,"_row":1},{"data":"line_data","x":2,"y":1.0798,"coef":0.0505,"int":-0.0243,"_row":2},{"data":"line_data","x":3,"y":1.1357,"coef":0.0505,"int":-0.0243,"_row":3},{"data":"line_data","x":4,"y":1.1945,"coef":0.0505,"int":-0.0243,"_row":4},{"data":"line_data","x":5,"y":1.2564,"coef":0.0505,"int":-0.0243,"_row":5},{"data":"line_data","x":6,"y":1.3215,"coef":0.0505,"int":-0.0243,"_row":6},{"data":"line_data","x":7,"y":1.39,"coef":0.0505,"int":-0.0243,"_row":7},{"data":"line_data","x":8,"y":1.462,"coef":0.0505,"int":-0.0243,"_row":8},{"data":"line_data","x":9,"y":1.5377,"coef":0.0505,"int":-0.0243,"_row":9},{"data":"line_data","x":10,"y":1.6174,"coef":0.0505,"int":-0.0243,"_row":10},{"data":"line_data","x":11,"y":1.7011,"coef":0.0505,"int":-0.0243,"_row":11},{"data":"line_data","x":12,"y":1.7893,"coef":0.0505,"int":-0.0243,"_row":12},{"data":"line_data","x":13,"y":1.882,"coef":0.0505,"int":-0.0243,"_row":13},{"data":"line_data","x":14,"y":1.9795,"coef":0.0505,"int":-0.0243,"_row":14},{"data":"line_data","x":15,"y":2.082,"coef":0.0505,"int":-0.0243,"_row":15},{"data":"line_data","x":16,"y":2.1899,"coef":0.0505,"int":-0.0243,"_row":16},{"data":"line_data","x":17,"y":2.3033,"coef":0.0505,"int":-0.0243,"_row":17},{"data":"line_data","x":18,"y":2.4226,"coef":0.0505,"int":-0.0243,"_row":18},{"data":"line_data","x":19,"y":2.5481,"coef":0.0505,"int":-0.0243,"_row":19},{"data":"line_data","x":20,"y":2.6801,"coef":0.0505,"int":-0.0243,"_row":20},{"data":"line_data","x":21,"y":2.819,"coef":0.0505,"int":-0.0243,"_row":21},{"data":"line_data","x":22,"y":2.965,"coef":0.0505,"int":-0.0243,"_row":22},{"data":"line_data","x":23,"y":3.1186,"coef":0.0505,"int":-0.0243,"_row":23},{"data":"line_data","x":24,"y":3.2801,"coef":0.0505,"int":-0.0243,"_row":24},{"data":"line_data","x":25,"y":3.4501,"coef":0.0505,"int":-0.0243,"_row":25},{"data":"line_data","x":26,"y":3.6288,"coef":0.0505,"int":-0.0243,"_row":26},{"data":"line_data","x":27,"y":3.8168,"coef":0.0505,"int":-0.0243,"_row":27},{"data":"line_data","x":28,"y":4.0145,"coef":0.0505,"int":-0.0243,"_row":28},{"data":"line_data","x":29,"y":4.2225,"coef":0.0505,"int":-0.0243,"_row":29},{"data":"line_data","x":30,"y":4.4412,"coef":0.0505,"int":-0.0243,"_row":30},{"data":"line_data","x":31,"y":4.6713,"coef":0.0505,"int":-0.0243,"_row":31},{"data":"line_data","x":32,"y":4.9133,"coef":0.0505,"int":-0.0243,"_row":32},{"data":"line_data","x":33,"y":5.1678,"coef":0.0505,"int":-0.0243,"_row":33},{"data":"line_data","x":34,"y":5.4355,"coef":0.0505,"int":-0.0243,"_row":34},{"data":"line_data","x":35,"y":5.7171,"coef":0.0505,"int":-0.0243,"_row":35},{"data":"line_data","x":36,"y":6.0133,"coef":0.0505,"int":-0.0243,"_row":36},{"data":"line_data","x":37,"y":6.3248,"coef":0.0505,"int":-0.0243,"_row":37},{"data":"line_data","x":38,"y":6.6524,"coef":0.0505,"int":-0.0243,"_row":38},{"data":"line_data","x":39,"y":6.9971,"coef":0.0505,"int":-0.0243,"_row":39},{"data":"line_data","x":40,"y":7.3595,"coef":0.0505,"int":-0.0243,"_row":40},{"data":"line_data","x":41,"y":7.7408,"coef":0.0505,"int":-0.0243,"_row":41},{"data":"line_data","x":42,"y":8.1418,"coef":0.0505,"int":-0.0243,"_row":42},{"data":"line_data","x":43,"y":8.5636,"coef":0.0505,"int":-0.0243,"_row":43},{"data":"line_data","x":44,"y":9.0072,"coef":0.0505,"int":-0.0243,"_row":44},{"data":"line_data","x":45,"y":9.4738,"coef":0.0505,"int":-0.0243,"_row":45},{"data":"line_data","x":46,"y":9.9646,"coef":0.0505,"int":-0.0243,"_row":46},{"data":"line_data","x":47,"y":10.4808,"coef":0.0505,"int":-0.0243,"_row":47},{"data":"line_data","x":48,"y":11.0237,"coef":0.0505,"int":-0.0243,"_row":48},{"data":"line_data","x":49,"y":11.5948,"coef":0.0505,"int":-0.0243,"_row":49},{"data":"line_data","x":50,"y":12.1955,"coef":0.0505,"int":-0.0243,"_row":50},{"data":"line_data","x":51,"y":12.8273,"coef":0.0505,"int":-0.0243,"_row":51},{"data":"line_data","x":52,"y":13.4918,"coef":0.0505,"int":-0.0243,"_row":52},{"data":"line_data","x":53,"y":14.1907,"coef":0.0505,"int":-0.0243,"_row":53},{"data":"line_data","x":54,"y":14.9258,"coef":0.0505,"int":-0.0243,"_row":54},{"data":"line_data","x":55,"y":15.699,"coef":0.0505,"int":-0.0243,"_row":55},{"data":"line_data","x":56,"y":16.5123,"coef":0.0505,"int":-0.0243,"_row":56},{"data":"line_data","x":57,"y":17.3677,"coef":0.0505,"int":-0.0243,"_row":57},{"data":"line_data","x":58,"y":18.2674,"coef":0.0505,"int":-0.0243,"_row":58},{"data":"line_data","x":59,"y":19.2137,"coef":0.0505,"int":-0.0243,"_row":59},{"data":"line_data","x":60,"y":20.2091,"coef":0.0505,"int":-0.0243,"_row":60},{"data":"line_data","x":61,"y":21.256,"coef":0.0505,"int":-0.0243,"_row":61},{"data":"line_data","x":62,"y":22.3572,"coef":0.0505,"int":-0.0243,"_row":62},{"data":"line_data","x":63,"y":23.5153,"coef":0.0505,"int":-0.0243,"_row":63},{"data":"line_data","x":64,"y":24.7335,"coef":0.0505,"int":-0.0243,"_row":64},{"data":"line_data","x":65,"y":26.0148,"coef":0.0505,"int":-0.0243,"_row":65},{"data":"line_data","x":66,"y":27.3625,"coef":0.0505,"int":-0.0243,"_row":66},{"data":"line_data","x":67,"y":28.78,"coef":0.0505,"int":-0.0243,"_row":67},{"data":"line_data","x":68,"y":30.2709,"coef":0.0505,"int":-0.0243,"_row":68},{"data":"line_data","x":69,"y":31.8391,"coef":0.0505,"int":-0.0243,"_row":69},{"data":"line_data","x":70,"y":33.4885,"coef":0.0505,"int":-0.0243,"_row":70},{"data":"line_data","x":71,"y":35.2233,"coef":0.0505,"int":-0.0243,"_row":71},{"data":"line_data","x":72,"y":37.048,"coef":0.0505,"int":-0.0243,"_row":72},{"data":"line_data","x":73,"y":38.9672,"coef":0.0505,"int":-0.0243,"_row":73},{"data":"line_data","x":74,"y":40.9859,"coef":0.0505,"int":-0.0243,"_row":74},{"data":"line_data","x":75,"y":43.1091,"coef":0.0505,"int":-0.0243,"_row":75},{"data":"line_data","x":76,"y":45.3423,"coef":0.0505,"int":-0.0243,"_row":76},{"data":"line_data","x":77,"y":47.6913,"coef":0.0505,"int":-0.0243,"_row":77},{"data":"line_data","x":78,"y":50.1619,"coef":0.0505,"int":-0.0243,"_row":78},{"data":"line_data","x":79,"y":52.7604,"coef":0.0505,"int":-0.0243,"_row":79},{"data":"line_data","x":80,"y":55.4936,"coef":0.0505,"int":-0.0243,"_row":80},{"data":"line_data","x":81,"y":58.3684,"coef":0.0505,"int":-0.0243,"_row":81},{"data":"line_data","x":82,"y":61.3922,"coef":0.0505,"int":-0.0243,"_row":82},{"data":"line_data","x":83,"y":64.5725,"coef":0.0505,"int":-0.0243,"_row":83},{"data":"line_data","x":84,"y":67.9176,"coef":0.0505,"int":-0.0243,"_row":84},{"data":"line_data","x":85,"y":71.436,"coef":0.0505,"int":-0.0243,"_row":85},{"data":"line_data","x":86,"y":75.1367,"coef":0.0505,"int":-0.0243,"_row":86},{"data":"line_data","x":87,"y":79.0291,"coef":0.0505,"int":-0.0243,"_row":87},{"data":"line_data","x":88,"y":83.1231,"coef":0.0505,"int":-0.0243,"_row":88},{"data":"line_data","x":89,"y":87.4292,"coef":0.0505,"int":-0.0243,"_row":89},{"data":"line_data","x":90,"y":91.9584,"coef":0.0505,"int":-0.0243,"_row":90},{"data":"line_data","x":91,"y":96.7222,"coef":0.0505,"int":-0.0243,"_row":91},{"data":"line_data","x":92,"y":101.7328,"coef":0.0505,"int":-0.0243,"_row":92},{"data":"line_data","x":93,"y":107.003,"coef":0.0505,"int":-0.0243,"_row":93},{"data":"line_data","x":94,"y":112.5462,"coef":0.0505,"int":-0.0243,"_row":94},{"data":"line_data","x":95,"y":118.3765,"coef":0.0505,"int":-0.0243,"_row":95},{"data":"line_data","x":96,"y":124.5089,"coef":0.0505,"int":-0.0243,"_row":96},{"data":"line_data","x":97,"y":130.9589,"coef":0.0505,"int":-0.0243,"_row":97},{"data":"line_data","x":98,"y":137.7431,"coef":0.0505,"int":-0.0243,"_row":98},{"data":"line_data","x":99,"y":144.8788,"coef":0.0505,"int":-0.0243,"_row":99},{"data":"line_data","x":100,"y":152.3841,"coef":0.0505,"int":-0.0243,"_row":100}],"point_data":[{"data":"point_data","x":1,"y":0.9334,"_row":1},{"data":"point_data","x":2,"y":1.0543,"_row":2},{"data":"point_data","x":3,"y":1.524,"_row":3},{"data":"point_data","x":4,"y":1.2386,"_row":4},{"data":"point_data","x":5,"y":1.3172,"_row":5},{"data":"point_data","x":6,"y":1.8129,"_row":6},{"data":"point_data","x":7,"y":1.5499,"_row":7},{"data":"point_data","x":8,"y":1.1144,"_row":8},{"data":"point_data","x":9,"y":1.3529,"_row":9},{"data":"point_data","x":10,"y":1.5018,"_row":10},{"data":"point_data","x":11,"y":2.1576,"_row":11},{"data":"point_data","x":12,"y":1.9532,"_row":12},{"data":"point_data","x":13,"y":2.0691,"_row":13},{"data":"point_data","x":14,"y":2.0583,"_row":14},{"data":"point_data","x":15,"y":1.8817,"_row":15},{"data":"point_data","x":16,"y":3.0209,"_row":16},{"data":"point_data","x":17,"y":2.5726,"_row":17},{"data":"point_data","x":18,"y":1.4922,"_row":18},{"data":"point_data","x":19,"y":2.9484,"_row":19},{"data":"point_data","x":20,"y":2.4612,"_row":20},{"data":"point_data","x":21,"y":2.2474,"_row":21},{"data":"point_data","x":22,"y":2.8732,"_row":22},{"data":"point_data","x":23,"y":2.5101,"_row":23},{"data":"point_data","x":24,"y":2.8361,"_row":24},{"data":"point_data","x":25,"y":3.054,"_row":25},{"data":"point_data","x":26,"y":2.4315,"_row":26},{"data":"point_data","x":27,"y":4.5038,"_row":27},{"data":"point_data","x":28,"y":4.1796,"_row":28},{"data":"point_data","x":29,"y":3.2927,"_row":29},{"data":"point_data","x":30,"y":5.6055,"_row":30},{"data":"point_data","x":31,"y":5.1133,"_row":31},{"data":"point_data","x":32,"y":4.6607,"_row":32},{"data":"point_data","x":33,"y":6.1392,"_row":33},{"data":"point_data","x":34,"y":6.4353,"_row":34},{"data":"point_data","x":35,"y":6.7002,"_row":35},{"data":"point_data","x":36,"y":6.8829,"_row":36},{"data":"point_data","x":37,"y":7.0644,"_row":37},{"data":"point_data","x":38,"y":6.6031,"_row":38},{"data":"point_data","x":39,"y":6.5986,"_row":39},{"data":"point_data","x":40,"y":6.8268,"_row":40},{"data":"point_data","x":41,"y":6.6886,"_row":41},{"data":"point_data","x":42,"y":7.8266,"_row":42},{"data":"point_data","x":43,"y":6.4122,"_row":43},{"data":"point_data","x":44,"y":12.94,"_row":44},{"data":"point_data","x":45,"y":11.7799,"_row":45},{"data":"point_data","x":46,"y":7.7338,"_row":46},{"data":"point_data","x":47,"y":9.6407,"_row":47},{"data":"point_data","x":48,"y":9.9944,"_row":48},{"data":"point_data","x":49,"y":13.396,"_row":49},{"data":"point_data","x":50,"y":11.9794,"_row":50},{"data":"point_data","x":51,"y":13.456,"_row":51},{"data":"point_data","x":52,"y":13.3869,"_row":52},{"data":"point_data","x":53,"y":14.0327,"_row":53},{"data":"point_data","x":54,"y":18.9526,"_row":54},{"data":"point_data","x":55,"y":14.9363,"_row":55},{"data":"point_data","x":56,"y":21.4322,"_row":56},{"data":"point_data","x":57,"y":11.9329,"_row":57},{"data":"point_data","x":58,"y":20.2991,"_row":58},{"data":"point_data","x":59,"y":19.5792,"_row":59},{"data":"point_data","x":60,"y":20.953,"_row":60},{"data":"point_data","x":61,"y":22.7186,"_row":61},{"data":"point_data","x":62,"y":19.9678,"_row":62},{"data":"point_data","x":63,"y":21.7809,"_row":63},{"data":"point_data","x":64,"y":19.5349,"_row":64},{"data":"point_data","x":65,"y":20.262,"_row":65},{"data":"point_data","x":66,"y":28.7585,"_row":66},{"data":"point_data","x":67,"y":31.0578,"_row":67},{"data":"point_data","x":68,"y":30.2817,"_row":68},{"data":"point_data","x":69,"y":37.3107,"_row":69},{"data":"point_data","x":70,"y":46.6933,"_row":70},{"data":"point_data","x":71,"y":31.3944,"_row":71},{"data":"point_data","x":72,"y":19.6959,"_row":72},{"data":"point_data","x":73,"y":46.2138,"_row":73},{"data":"point_data","x":74,"y":34.7103,"_row":74},{"data":"point_data","x":75,"y":36.6701,"_row":75},{"data":"point_data","x":76,"y":53.87,"_row":76},{"data":"point_data","x":77,"y":44.3166,"_row":77},{"data":"point_data","x":78,"y":37.3412,"_row":78},{"data":"point_data","x":79,"y":53.8186,"_row":79},{"data":"point_data","x":80,"y":53.0815,"_row":80},{"data":"point_data","x":81,"y":57.4636,"_row":81},{"data":"point_data","x":82,"y":64.9899,"_row":82},{"data":"point_data","x":83,"y":58.7315,"_row":83},{"data":"point_data","x":84,"y":75.2806,"_row":84},{"data":"point_data","x":85,"y":67.014,"_row":85},{"data":"point_data","x":86,"y":78.5902,"_row":86},{"data":"point_data","x":87,"y":94.4747,"_row":87},{"data":"point_data","x":88,"y":88.5401,"_row":88},{"data":"point_data","x":89,"y":80.0452,"_row":89},{"data":"point_data","x":90,"y":110.6996,"_row":90},{"data":"point_data","x":91,"y":113.4359,"_row":91},{"data":"point_data","x":92,"y":110.3957,"_row":92},{"data":"point_data","x":93,"y":109.5785,"_row":93},{"data":"point_data","x":94,"y":96.1399,"_row":94},{"data":"point_data","x":95,"y":147.0383,"_row":95},{"data":"point_data","x":96,"y":106.9229,"_row":96},{"data":"point_data","x":97,"y":183.6225,"_row":97},{"data":"point_data","x":98,"y":175.4526,"_row":98},{"data":"point_data","x":99,"y":134.52,"_row":99},{"data":"point_data","x":100,"y":117.9463,"_row":100}]},"type":"json","container":"svg","options":{"draw_start":1,"hide_buttons":false,"points_end":null,"linear":"FALSE","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[1,100],"x_by":0,"x_lab":"","y_range":[0.02623271379396519,192.8023592453546],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Log Scale","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>In the plot above, you can try to draw the trend line. You’ll notice
that despite the original data having an exponential relationship
between x and y, the line data and point data on the log scale exhibit a
linear relationship. Hence, plotting data on a logarithmic scale can
simplify the task of identifying and drawing trends in data that have
exponential growth patterns.</p>
<p>Let’s compare to how the graph would look on a linear scale:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Generate custom data</span></span>
<span><span class="va">custom_data_linear</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/customDataGen.html">customDataGen</a></span><span class="op">(</span></span>
<span>  df <span class="op">=</span> <span class="va">exp_data</span>,</span>
<span>  regression_type <span class="op">=</span> <span class="st">"linear"</span>,</span>
<span>  log_y <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the data with a linear y-scale</span></span>
<span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span><span class="va">custom_data_linear</span>,</span>
<span>      linear <span class="op">=</span> <span class="st">"true"</span>,</span>
<span>      title <span class="op">=</span> <span class="st">"Linear Scale"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-2f0b355bf4282db2283d" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-2f0b355bf4282db2283d">{"x":{"data":{"line_data":[{"data":"line_data","x":1,"y":-26.8688,"coef":1.1812,"int":-28.05,"_row":1},{"data":"line_data","x":2,"y":-25.6875,"coef":1.1812,"int":-28.05,"_row":2},{"data":"line_data","x":3,"y":-24.5063,"coef":1.1812,"int":-28.05,"_row":3},{"data":"line_data","x":4,"y":-23.325,"coef":1.1812,"int":-28.05,"_row":4},{"data":"line_data","x":5,"y":-22.1438,"coef":1.1812,"int":-28.05,"_row":5},{"data":"line_data","x":6,"y":-20.9625,"coef":1.1812,"int":-28.05,"_row":6},{"data":"line_data","x":7,"y":-19.7813,"coef":1.1812,"int":-28.05,"_row":7},{"data":"line_data","x":8,"y":-18.6001,"coef":1.1812,"int":-28.05,"_row":8},{"data":"line_data","x":9,"y":-17.4188,"coef":1.1812,"int":-28.05,"_row":9},{"data":"line_data","x":10,"y":-16.2376,"coef":1.1812,"int":-28.05,"_row":10},{"data":"line_data","x":11,"y":-15.0563,"coef":1.1812,"int":-28.05,"_row":11},{"data":"line_data","x":12,"y":-13.8751,"coef":1.1812,"int":-28.05,"_row":12},{"data":"line_data","x":13,"y":-12.6938,"coef":1.1812,"int":-28.05,"_row":13},{"data":"line_data","x":14,"y":-11.5126,"coef":1.1812,"int":-28.05,"_row":14},{"data":"line_data","x":15,"y":-10.3313,"coef":1.1812,"int":-28.05,"_row":15},{"data":"line_data","x":16,"y":-9.1501,"coef":1.1812,"int":-28.05,"_row":16},{"data":"line_data","x":17,"y":-7.9688,"coef":1.1812,"int":-28.05,"_row":17},{"data":"line_data","x":18,"y":-6.7876,"coef":1.1812,"int":-28.05,"_row":18},{"data":"line_data","x":19,"y":-5.6064,"coef":1.1812,"int":-28.05,"_row":19},{"data":"line_data","x":20,"y":-4.4251,"coef":1.1812,"int":-28.05,"_row":20},{"data":"line_data","x":21,"y":-3.2439,"coef":1.1812,"int":-28.05,"_row":21},{"data":"line_data","x":22,"y":-2.0626,"coef":1.1812,"int":-28.05,"_row":22},{"data":"line_data","x":23,"y":-0.8814,"coef":1.1812,"int":-28.05,"_row":23},{"data":"line_data","x":24,"y":0.2999,"coef":1.1812,"int":-28.05,"_row":24},{"data":"line_data","x":25,"y":1.4811,"coef":1.1812,"int":-28.05,"_row":25},{"data":"line_data","x":26,"y":2.6624,"coef":1.1812,"int":-28.05,"_row":26},{"data":"line_data","x":27,"y":3.8436,"coef":1.1812,"int":-28.05,"_row":27},{"data":"line_data","x":28,"y":5.0248,"coef":1.1812,"int":-28.05,"_row":28},{"data":"line_data","x":29,"y":6.2061,"coef":1.1812,"int":-28.05,"_row":29},{"data":"line_data","x":30,"y":7.3873,"coef":1.1812,"int":-28.05,"_row":30},{"data":"line_data","x":31,"y":8.5686,"coef":1.1812,"int":-28.05,"_row":31},{"data":"line_data","x":32,"y":9.7498,"coef":1.1812,"int":-28.05,"_row":32},{"data":"line_data","x":33,"y":10.9311,"coef":1.1812,"int":-28.05,"_row":33},{"data":"line_data","x":34,"y":12.1123,"coef":1.1812,"int":-28.05,"_row":34},{"data":"line_data","x":35,"y":13.2936,"coef":1.1812,"int":-28.05,"_row":35},{"data":"line_data","x":36,"y":14.4748,"coef":1.1812,"int":-28.05,"_row":36},{"data":"line_data","x":37,"y":15.6561,"coef":1.1812,"int":-28.05,"_row":37},{"data":"line_data","x":38,"y":16.8373,"coef":1.1812,"int":-28.05,"_row":38},{"data":"line_data","x":39,"y":18.0185,"coef":1.1812,"int":-28.05,"_row":39},{"data":"line_data","x":40,"y":19.1998,"coef":1.1812,"int":-28.05,"_row":40},{"data":"line_data","x":41,"y":20.381,"coef":1.1812,"int":-28.05,"_row":41},{"data":"line_data","x":42,"y":21.5623,"coef":1.1812,"int":-28.05,"_row":42},{"data":"line_data","x":43,"y":22.7435,"coef":1.1812,"int":-28.05,"_row":43},{"data":"line_data","x":44,"y":23.9248,"coef":1.1812,"int":-28.05,"_row":44},{"data":"line_data","x":45,"y":25.106,"coef":1.1812,"int":-28.05,"_row":45},{"data":"line_data","x":46,"y":26.2873,"coef":1.1812,"int":-28.05,"_row":46},{"data":"line_data","x":47,"y":27.4685,"coef":1.1812,"int":-28.05,"_row":47},{"data":"line_data","x":48,"y":28.6497,"coef":1.1812,"int":-28.05,"_row":48},{"data":"line_data","x":49,"y":29.831,"coef":1.1812,"int":-28.05,"_row":49},{"data":"line_data","x":50,"y":31.0122,"coef":1.1812,"int":-28.05,"_row":50},{"data":"line_data","x":51,"y":32.1935,"coef":1.1812,"int":-28.05,"_row":51},{"data":"line_data","x":52,"y":33.3747,"coef":1.1812,"int":-28.05,"_row":52},{"data":"line_data","x":53,"y":34.556,"coef":1.1812,"int":-28.05,"_row":53},{"data":"line_data","x":54,"y":35.7372,"coef":1.1812,"int":-28.05,"_row":54},{"data":"line_data","x":55,"y":36.9185,"coef":1.1812,"int":-28.05,"_row":55},{"data":"line_data","x":56,"y":38.0997,"coef":1.1812,"int":-28.05,"_row":56},{"data":"line_data","x":57,"y":39.281,"coef":1.1812,"int":-28.05,"_row":57},{"data":"line_data","x":58,"y":40.4622,"coef":1.1812,"int":-28.05,"_row":58},{"data":"line_data","x":59,"y":41.6434,"coef":1.1812,"int":-28.05,"_row":59},{"data":"line_data","x":60,"y":42.8247,"coef":1.1812,"int":-28.05,"_row":60},{"data":"line_data","x":61,"y":44.0059,"coef":1.1812,"int":-28.05,"_row":61},{"data":"line_data","x":62,"y":45.1872,"coef":1.1812,"int":-28.05,"_row":62},{"data":"line_data","x":63,"y":46.3684,"coef":1.1812,"int":-28.05,"_row":63},{"data":"line_data","x":64,"y":47.5497,"coef":1.1812,"int":-28.05,"_row":64},{"data":"line_data","x":65,"y":48.7309,"coef":1.1812,"int":-28.05,"_row":65},{"data":"line_data","x":66,"y":49.9122,"coef":1.1812,"int":-28.05,"_row":66},{"data":"line_data","x":67,"y":51.0934,"coef":1.1812,"int":-28.05,"_row":67},{"data":"line_data","x":68,"y":52.2746,"coef":1.1812,"int":-28.05,"_row":68},{"data":"line_data","x":69,"y":53.4559,"coef":1.1812,"int":-28.05,"_row":69},{"data":"line_data","x":70,"y":54.6371,"coef":1.1812,"int":-28.05,"_row":70},{"data":"line_data","x":71,"y":55.8184,"coef":1.1812,"int":-28.05,"_row":71},{"data":"line_data","x":72,"y":56.9996,"coef":1.1812,"int":-28.05,"_row":72},{"data":"line_data","x":73,"y":58.1809,"coef":1.1812,"int":-28.05,"_row":73},{"data":"line_data","x":74,"y":59.3621,"coef":1.1812,"int":-28.05,"_row":74},{"data":"line_data","x":75,"y":60.5434,"coef":1.1812,"int":-28.05,"_row":75},{"data":"line_data","x":76,"y":61.7246,"coef":1.1812,"int":-28.05,"_row":76},{"data":"line_data","x":77,"y":62.9059,"coef":1.1812,"int":-28.05,"_row":77},{"data":"line_data","x":78,"y":64.0871,"coef":1.1812,"int":-28.05,"_row":78},{"data":"line_data","x":79,"y":65.2683,"coef":1.1812,"int":-28.05,"_row":79},{"data":"line_data","x":80,"y":66.4496,"coef":1.1812,"int":-28.05,"_row":80},{"data":"line_data","x":81,"y":67.6308,"coef":1.1812,"int":-28.05,"_row":81},{"data":"line_data","x":82,"y":68.8121,"coef":1.1812,"int":-28.05,"_row":82},{"data":"line_data","x":83,"y":69.9933,"coef":1.1812,"int":-28.05,"_row":83},{"data":"line_data","x":84,"y":71.1746,"coef":1.1812,"int":-28.05,"_row":84},{"data":"line_data","x":85,"y":72.3558,"coef":1.1812,"int":-28.05,"_row":85},{"data":"line_data","x":86,"y":73.5371,"coef":1.1812,"int":-28.05,"_row":86},{"data":"line_data","x":87,"y":74.7183,"coef":1.1812,"int":-28.05,"_row":87},{"data":"line_data","x":88,"y":75.8995,"coef":1.1812,"int":-28.05,"_row":88},{"data":"line_data","x":89,"y":77.0808,"coef":1.1812,"int":-28.05,"_row":89},{"data":"line_data","x":90,"y":78.262,"coef":1.1812,"int":-28.05,"_row":90},{"data":"line_data","x":91,"y":79.4433,"coef":1.1812,"int":-28.05,"_row":91},{"data":"line_data","x":92,"y":80.6245,"coef":1.1812,"int":-28.05,"_row":92},{"data":"line_data","x":93,"y":81.8058,"coef":1.1812,"int":-28.05,"_row":93},{"data":"line_data","x":94,"y":82.987,"coef":1.1812,"int":-28.05,"_row":94},{"data":"line_data","x":95,"y":84.1683,"coef":1.1812,"int":-28.05,"_row":95},{"data":"line_data","x":96,"y":85.3495,"coef":1.1812,"int":-28.05,"_row":96},{"data":"line_data","x":97,"y":86.5308,"coef":1.1812,"int":-28.05,"_row":97},{"data":"line_data","x":98,"y":87.712,"coef":1.1812,"int":-28.05,"_row":98},{"data":"line_data","x":99,"y":88.8932,"coef":1.1812,"int":-28.05,"_row":99},{"data":"line_data","x":100,"y":90.0745,"coef":1.1812,"int":-28.05,"_row":100}],"point_data":[{"data":"point_data","x":1,"y":0.9334,"_row":1},{"data":"point_data","x":2,"y":1.0543,"_row":2},{"data":"point_data","x":3,"y":1.524,"_row":3},{"data":"point_data","x":4,"y":1.2386,"_row":4},{"data":"point_data","x":5,"y":1.3172,"_row":5},{"data":"point_data","x":6,"y":1.8129,"_row":6},{"data":"point_data","x":7,"y":1.5499,"_row":7},{"data":"point_data","x":8,"y":1.1144,"_row":8},{"data":"point_data","x":9,"y":1.3529,"_row":9},{"data":"point_data","x":10,"y":1.5018,"_row":10},{"data":"point_data","x":11,"y":2.1576,"_row":11},{"data":"point_data","x":12,"y":1.9532,"_row":12},{"data":"point_data","x":13,"y":2.0691,"_row":13},{"data":"point_data","x":14,"y":2.0583,"_row":14},{"data":"point_data","x":15,"y":1.8817,"_row":15},{"data":"point_data","x":16,"y":3.0209,"_row":16},{"data":"point_data","x":17,"y":2.5726,"_row":17},{"data":"point_data","x":18,"y":1.4922,"_row":18},{"data":"point_data","x":19,"y":2.9484,"_row":19},{"data":"point_data","x":20,"y":2.4612,"_row":20},{"data":"point_data","x":21,"y":2.2474,"_row":21},{"data":"point_data","x":22,"y":2.8732,"_row":22},{"data":"point_data","x":23,"y":2.5101,"_row":23},{"data":"point_data","x":24,"y":2.8361,"_row":24},{"data":"point_data","x":25,"y":3.054,"_row":25},{"data":"point_data","x":26,"y":2.4315,"_row":26},{"data":"point_data","x":27,"y":4.5038,"_row":27},{"data":"point_data","x":28,"y":4.1796,"_row":28},{"data":"point_data","x":29,"y":3.2927,"_row":29},{"data":"point_data","x":30,"y":5.6055,"_row":30},{"data":"point_data","x":31,"y":5.1133,"_row":31},{"data":"point_data","x":32,"y":4.6607,"_row":32},{"data":"point_data","x":33,"y":6.1392,"_row":33},{"data":"point_data","x":34,"y":6.4353,"_row":34},{"data":"point_data","x":35,"y":6.7002,"_row":35},{"data":"point_data","x":36,"y":6.8829,"_row":36},{"data":"point_data","x":37,"y":7.0644,"_row":37},{"data":"point_data","x":38,"y":6.6031,"_row":38},{"data":"point_data","x":39,"y":6.5986,"_row":39},{"data":"point_data","x":40,"y":6.8268,"_row":40},{"data":"point_data","x":41,"y":6.6886,"_row":41},{"data":"point_data","x":42,"y":7.8266,"_row":42},{"data":"point_data","x":43,"y":6.4122,"_row":43},{"data":"point_data","x":44,"y":12.94,"_row":44},{"data":"point_data","x":45,"y":11.7799,"_row":45},{"data":"point_data","x":46,"y":7.7338,"_row":46},{"data":"point_data","x":47,"y":9.6407,"_row":47},{"data":"point_data","x":48,"y":9.9944,"_row":48},{"data":"point_data","x":49,"y":13.396,"_row":49},{"data":"point_data","x":50,"y":11.9794,"_row":50},{"data":"point_data","x":51,"y":13.456,"_row":51},{"data":"point_data","x":52,"y":13.3869,"_row":52},{"data":"point_data","x":53,"y":14.0327,"_row":53},{"data":"point_data","x":54,"y":18.9526,"_row":54},{"data":"point_data","x":55,"y":14.9363,"_row":55},{"data":"point_data","x":56,"y":21.4322,"_row":56},{"data":"point_data","x":57,"y":11.9329,"_row":57},{"data":"point_data","x":58,"y":20.2991,"_row":58},{"data":"point_data","x":59,"y":19.5792,"_row":59},{"data":"point_data","x":60,"y":20.953,"_row":60},{"data":"point_data","x":61,"y":22.7186,"_row":61},{"data":"point_data","x":62,"y":19.9678,"_row":62},{"data":"point_data","x":63,"y":21.7809,"_row":63},{"data":"point_data","x":64,"y":19.5349,"_row":64},{"data":"point_data","x":65,"y":20.262,"_row":65},{"data":"point_data","x":66,"y":28.7585,"_row":66},{"data":"point_data","x":67,"y":31.0578,"_row":67},{"data":"point_data","x":68,"y":30.2817,"_row":68},{"data":"point_data","x":69,"y":37.3107,"_row":69},{"data":"point_data","x":70,"y":46.6933,"_row":70},{"data":"point_data","x":71,"y":31.3944,"_row":71},{"data":"point_data","x":72,"y":19.6959,"_row":72},{"data":"point_data","x":73,"y":46.2138,"_row":73},{"data":"point_data","x":74,"y":34.7103,"_row":74},{"data":"point_data","x":75,"y":36.6701,"_row":75},{"data":"point_data","x":76,"y":53.87,"_row":76},{"data":"point_data","x":77,"y":44.3166,"_row":77},{"data":"point_data","x":78,"y":37.3412,"_row":78},{"data":"point_data","x":79,"y":53.8186,"_row":79},{"data":"point_data","x":80,"y":53.0815,"_row":80},{"data":"point_data","x":81,"y":57.4636,"_row":81},{"data":"point_data","x":82,"y":64.9899,"_row":82},{"data":"point_data","x":83,"y":58.7315,"_row":83},{"data":"point_data","x":84,"y":75.2806,"_row":84},{"data":"point_data","x":85,"y":67.014,"_row":85},{"data":"point_data","x":86,"y":78.5902,"_row":86},{"data":"point_data","x":87,"y":94.4747,"_row":87},{"data":"point_data","x":88,"y":88.5401,"_row":88},{"data":"point_data","x":89,"y":80.0452,"_row":89},{"data":"point_data","x":90,"y":110.6996,"_row":90},{"data":"point_data","x":91,"y":113.4359,"_row":91},{"data":"point_data","x":92,"y":110.3957,"_row":92},{"data":"point_data","x":93,"y":109.5785,"_row":93},{"data":"point_data","x":94,"y":96.1399,"_row":94},{"data":"point_data","x":95,"y":147.0383,"_row":95},{"data":"point_data","x":96,"y":106.9229,"_row":96},{"data":"point_data","x":97,"y":183.6225,"_row":97},{"data":"point_data","x":98,"y":175.4526,"_row":98},{"data":"point_data","x":99,"y":134.52,"_row":99},{"data":"point_data","x":100,"y":117.9463,"_row":100}]},"type":"json","container":"svg","options":{"draw_start":1,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[1,100],"x_by":0,"x_lab":"","y_range":[-37.39333099161928,194.147109157559],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Linear Scale","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>As you can see, the exponential nature of the data is much more
challenging to draw and understand on a linear scale. Although there may
be different regression types that could potentially fit this trend
better on a linear scale, transforming the data to a logarithmic scale
is always a viable option. It transforms complex exponential growth
patterns into more straightforward linear relationships, making the task
of drawing and understanding trends significantly easier.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Emily A. Robinson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
