<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="youdrawitR">
<title>Guide: Plot Customization and Button Usage â€¢ youdrawitR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Guide: Plot Customization and Button Usage">
<meta property="og:description" content="youdrawitR">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">youdrawitR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Examples</h6>
    <a class="dropdown-item" href="../articles/customDataGen.html">customDataGen</a>
    <a class="dropdown-item" href="../articles/linearDataGen.html">linearDataGen</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Extra</h6>
    <a class="dropdown-item" href="../articles/web_only/ShinyApp.html">Shiny App</a>
    <a class="dropdown-item" href="../articles/customizing.html">Plot &amp; Button Guide</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/earobinson95/youdrawitR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">



<script src="customizing_files/htmlwidgets-1.6.2/htmlwidgets.js"></script><script src="customizing_files/r2d3-render-0.1.0/r2d3-render.js"></script><script src="customizing_files/webcomponents-2.0.0/webcomponents.js"></script><script src="customizing_files/r2d3-binding-0.2.6/r2d3.js"></script><script src="customizing_files/d3v5-5.9.2/d3.min.js"></script><script src="customizing_files/d3-jetpack-2.0.9/d3-jetpack.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Guide: Plot Customization and Button Usage</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/earobinson95/youdrawitR/blob/HEAD/vignettes/customizing.Rmd" class="external-link"><code>vignettes/customizing.Rmd</code></a></small>
      <div class="d-none name"><code>customizing.Rmd</code></div>
    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://earobinson95.github.io/youdrawitR/">youdrawitR</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/linearDataGen.html">linearDataGen</a></span><span class="op">(</span>y_int <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                      slope <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                      sigma <span class="op">=</span> <span class="fl">1.5</span>,</span>
<span>                      N <span class="op">=</span> <span class="fl">30</span>,</span>
<span>                      conf_int <span class="op">=</span> <span class="cn">F</span><span class="op">)</span></span></code></pre></div>
<p>The YouDrawIt package allows for creating interactive plots where
users can make their own predictions and see how they match up to the
actual data. The package is equipped with a multitude of customization
options and this guide will help you to understand how you can customize
the plots created by the <code><a href="../reference/drawr.html">drawr()</a></code> function and make the most
of the button features.</p>
<div class="section level2">
<h2 id="customizing-the-plot">Customizing The Plot<a class="anchor" aria-label="anchor" href="#customizing-the-plot"></a>
</h2>
<div class="section level3">
<h3 id="axis-range-labels">Axis Range &amp; Labels<a class="anchor" aria-label="anchor" href="#axis-range-labels"></a>
</h3>
<p>There are two ways to customize the range of values displayed on the
x and y axis. Be aware, even if the specified range is smaller than the
range of the point data, the line is still fitted for all points in the
dataset.</p>
<p>The first way is to specify the <code>x_range</code> and
<code>y_range</code> that you want for the data. If left as NULL (the
default), the function will automatically use the range of the max of
the line and point data x and y values.</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, x_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">25</span><span class="op">)</span>, y_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in drawr(data = data, x_range = c(0, 25), y_range = c(-2, 20)): The</span></span>
<span><span class="co">#&gt; provided y_range does not cover data, the line will still be fitted from entire</span></span>
<span><span class="co">#&gt; dataset.</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-44474b3e8cd160f85a98" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-44474b3e8cd160f85a98">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29}],"line_data":[{"x":0,"y":0.4644,"_row":1},{"x":0.25,"y":0.7011,"_row":2},{"x":0.5,"y":0.9377,"_row":3},{"x":0.75,"y":1.1743,"_row":4},{"x":1,"y":1.4109,"_row":5},{"x":1.25,"y":1.6476,"_row":6},{"x":1.5,"y":1.8842,"_row":7},{"x":1.75,"y":2.1208,"_row":8},{"x":2,"y":2.3574,"_row":9},{"x":2.25,"y":2.594,"_row":10},{"x":2.5,"y":2.8307,"_row":11},{"x":2.75,"y":3.0673,"_row":12},{"x":3,"y":3.3039,"_row":13},{"x":3.25,"y":3.5405,"_row":14},{"x":3.5,"y":3.7772,"_row":15},{"x":3.75,"y":4.0138,"_row":16},{"x":4,"y":4.2504,"_row":17},{"x":4.25,"y":4.487,"_row":18},{"x":4.5,"y":4.7236,"_row":19},{"x":4.75,"y":4.9603,"_row":20},{"x":5,"y":5.1969,"_row":21},{"x":5.25,"y":5.4335,"_row":22},{"x":5.5,"y":5.6701,"_row":23},{"x":5.75,"y":5.9068,"_row":24},{"x":6,"y":6.1434,"_row":25},{"x":6.25,"y":6.38,"_row":26},{"x":6.5,"y":6.6166,"_row":27},{"x":6.75,"y":6.8533,"_row":28},{"x":7,"y":7.0899,"_row":29},{"x":7.25,"y":7.3265,"_row":30},{"x":7.5,"y":7.5631,"_row":31},{"x":7.75,"y":7.7997,"_row":32},{"x":8,"y":8.0364,"_row":33},{"x":8.25,"y":8.273,"_row":34},{"x":8.5,"y":8.5096,"_row":35},{"x":8.75,"y":8.7462,"_row":36},{"x":9,"y":8.9829,"_row":37},{"x":9.25,"y":9.2195,"_row":38},{"x":9.5,"y":9.4561,"_row":39},{"x":9.75,"y":9.6927,"_row":40},{"x":10,"y":9.9293,"_row":41},{"x":10.25,"y":10.166,"_row":42},{"x":10.5,"y":10.4026,"_row":43},{"x":10.75,"y":10.6392,"_row":44},{"x":11,"y":10.8758,"_row":45},{"x":11.25,"y":11.1125,"_row":46},{"x":11.5,"y":11.3491,"_row":47},{"x":11.75,"y":11.5857,"_row":48},{"x":12,"y":11.8223,"_row":49},{"x":12.25,"y":12.0589,"_row":50},{"x":12.5,"y":12.2956,"_row":51},{"x":12.75,"y":12.5322,"_row":52},{"x":13,"y":12.7688,"_row":53},{"x":13.25,"y":13.0054,"_row":54},{"x":13.5,"y":13.2421,"_row":55},{"x":13.75,"y":13.4787,"_row":56},{"x":14,"y":13.7153,"_row":57},{"x":14.25,"y":13.9519,"_row":58},{"x":14.5,"y":14.1886,"_row":59},{"x":14.75,"y":14.4252,"_row":60},{"x":15,"y":14.6618,"_row":61},{"x":15.25,"y":14.8984,"_row":62},{"x":15.5,"y":15.135,"_row":63},{"x":15.75,"y":15.3717,"_row":64},{"x":16,"y":15.6083,"_row":65},{"x":16.25,"y":15.8449,"_row":66},{"x":16.5,"y":16.0815,"_row":67},{"x":16.75,"y":16.3182,"_row":68},{"x":17,"y":16.5548,"_row":69},{"x":17.25,"y":16.7914,"_row":70},{"x":17.5,"y":17.028,"_row":71},{"x":17.75,"y":17.2646,"_row":72},{"x":18,"y":17.5013,"_row":73},{"x":18.25,"y":17.7379,"_row":74},{"x":18.5,"y":17.9745,"_row":75},{"x":18.75,"y":18.2111,"_row":76},{"x":19,"y":18.4478,"_row":77},{"x":19.25,"y":18.6844,"_row":78},{"x":19.5,"y":18.921,"_row":79},{"x":19.75,"y":19.1576,"_row":80},{"x":20,"y":19.3942,"_row":81},{"x":25,"y":24.1267,"_row":82}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,25],"x_by":0,"x_lab":"","y_range":[-2,20],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><p>The second way is to specify a <code>x_axis_buffer</code> or
<code>y_axis_buffer</code>. This will add a buffer to the axis, as a
percent of total range. Thus, your input must be greater than or equal
to 0.</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, x_axis_buffer <span class="op">=</span> <span class="fl">0.1</span>, y_axis_buffer <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-2514ce28ae593bde0f73" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-2514ce28ae593bde0f73">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"x":-2,"y":-1.4285,"_row":1},{"x":0,"y":0.4644,"_row":2},{"x":0.25,"y":0.7011,"_row":3},{"x":0.5,"y":0.9377,"_row":4},{"x":0.75,"y":1.1743,"_row":5},{"x":1,"y":1.4109,"_row":6},{"x":1.25,"y":1.6476,"_row":7},{"x":1.5,"y":1.8842,"_row":8},{"x":1.75,"y":2.1208,"_row":9},{"x":2,"y":2.3574,"_row":10},{"x":2.25,"y":2.594,"_row":11},{"x":2.5,"y":2.8307,"_row":12},{"x":2.75,"y":3.0673,"_row":13},{"x":3,"y":3.3039,"_row":14},{"x":3.25,"y":3.5405,"_row":15},{"x":3.5,"y":3.7772,"_row":16},{"x":3.75,"y":4.0138,"_row":17},{"x":4,"y":4.2504,"_row":18},{"x":4.25,"y":4.487,"_row":19},{"x":4.5,"y":4.7236,"_row":20},{"x":4.75,"y":4.9603,"_row":21},{"x":5,"y":5.1969,"_row":22},{"x":5.25,"y":5.4335,"_row":23},{"x":5.5,"y":5.6701,"_row":24},{"x":5.75,"y":5.9068,"_row":25},{"x":6,"y":6.1434,"_row":26},{"x":6.25,"y":6.38,"_row":27},{"x":6.5,"y":6.6166,"_row":28},{"x":6.75,"y":6.8533,"_row":29},{"x":7,"y":7.0899,"_row":30},{"x":7.25,"y":7.3265,"_row":31},{"x":7.5,"y":7.5631,"_row":32},{"x":7.75,"y":7.7997,"_row":33},{"x":8,"y":8.0364,"_row":34},{"x":8.25,"y":8.273,"_row":35},{"x":8.5,"y":8.5096,"_row":36},{"x":8.75,"y":8.7462,"_row":37},{"x":9,"y":8.9829,"_row":38},{"x":9.25,"y":9.2195,"_row":39},{"x":9.5,"y":9.4561,"_row":40},{"x":9.75,"y":9.6927,"_row":41},{"x":10,"y":9.9293,"_row":42},{"x":10.25,"y":10.166,"_row":43},{"x":10.5,"y":10.4026,"_row":44},{"x":10.75,"y":10.6392,"_row":45},{"x":11,"y":10.8758,"_row":46},{"x":11.25,"y":11.1125,"_row":47},{"x":11.5,"y":11.3491,"_row":48},{"x":11.75,"y":11.5857,"_row":49},{"x":12,"y":11.8223,"_row":50},{"x":12.25,"y":12.0589,"_row":51},{"x":12.5,"y":12.2956,"_row":52},{"x":12.75,"y":12.5322,"_row":53},{"x":13,"y":12.7688,"_row":54},{"x":13.25,"y":13.0054,"_row":55},{"x":13.5,"y":13.2421,"_row":56},{"x":13.75,"y":13.4787,"_row":57},{"x":14,"y":13.7153,"_row":58},{"x":14.25,"y":13.9519,"_row":59},{"x":14.5,"y":14.1886,"_row":60},{"x":14.75,"y":14.4252,"_row":61},{"x":15,"y":14.6618,"_row":62},{"x":15.25,"y":14.8984,"_row":63},{"x":15.5,"y":15.135,"_row":64},{"x":15.75,"y":15.3717,"_row":65},{"x":16,"y":15.6083,"_row":66},{"x":16.25,"y":15.8449,"_row":67},{"x":16.5,"y":16.0815,"_row":68},{"x":16.75,"y":16.3182,"_row":69},{"x":17,"y":16.5548,"_row":70},{"x":17.25,"y":16.7914,"_row":71},{"x":17.5,"y":17.028,"_row":72},{"x":17.75,"y":17.2646,"_row":73},{"x":18,"y":17.5013,"_row":74},{"x":18.25,"y":17.7379,"_row":75},{"x":18.5,"y":17.9745,"_row":76},{"x":18.75,"y":18.2111,"_row":77},{"x":19,"y":18.4478,"_row":78},{"x":19.25,"y":18.6844,"_row":79},{"x":19.5,"y":18.921,"_row":80},{"x":19.75,"y":19.1576,"_row":81},{"x":20,"y":19.3942,"_row":82},{"x":22,"y":21.2872,"_row":83}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[-2,22],"x_by":0,"x_lab":"","y_range":[-3.11285705497164,24.15286596674821],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><p>To add axis labels use the <code>x_lab</code> and <code>y_lab</code>
parameters. To add titles use the <code>title</code> and
<code>subtitle</code> parameters. Here is an example of how to use these
parameters.</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, title <span class="op">=</span> <span class="st">"Sales Over Time"</span>, x_lab <span class="op">=</span> <span class="st">"Time"</span>, y_lab <span class="op">=</span> <span class="st">"Sales"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-5d05eac75555269eefd0" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-5d05eac75555269eefd0">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.4644,"coef":0.9465,"int":0.4644,"_row":1},{"data":"line_data","x":0.25,"y":0.7011,"coef":0.9465,"int":0.4644,"_row":2},{"data":"line_data","x":0.5,"y":0.9377,"coef":0.9465,"int":0.4644,"_row":3},{"data":"line_data","x":0.75,"y":1.1743,"coef":0.9465,"int":0.4644,"_row":4},{"data":"line_data","x":1,"y":1.4109,"coef":0.9465,"int":0.4644,"_row":5},{"data":"line_data","x":1.25,"y":1.6476,"coef":0.9465,"int":0.4644,"_row":6},{"data":"line_data","x":1.5,"y":1.8842,"coef":0.9465,"int":0.4644,"_row":7},{"data":"line_data","x":1.75,"y":2.1208,"coef":0.9465,"int":0.4644,"_row":8},{"data":"line_data","x":2,"y":2.3574,"coef":0.9465,"int":0.4644,"_row":9},{"data":"line_data","x":2.25,"y":2.594,"coef":0.9465,"int":0.4644,"_row":10},{"data":"line_data","x":2.5,"y":2.8307,"coef":0.9465,"int":0.4644,"_row":11},{"data":"line_data","x":2.75,"y":3.0673,"coef":0.9465,"int":0.4644,"_row":12},{"data":"line_data","x":3,"y":3.3039,"coef":0.9465,"int":0.4644,"_row":13},{"data":"line_data","x":3.25,"y":3.5405,"coef":0.9465,"int":0.4644,"_row":14},{"data":"line_data","x":3.5,"y":3.7772,"coef":0.9465,"int":0.4644,"_row":15},{"data":"line_data","x":3.75,"y":4.0138,"coef":0.9465,"int":0.4644,"_row":16},{"data":"line_data","x":4,"y":4.2504,"coef":0.9465,"int":0.4644,"_row":17},{"data":"line_data","x":4.25,"y":4.487,"coef":0.9465,"int":0.4644,"_row":18},{"data":"line_data","x":4.5,"y":4.7236,"coef":0.9465,"int":0.4644,"_row":19},{"data":"line_data","x":4.75,"y":4.9603,"coef":0.9465,"int":0.4644,"_row":20},{"data":"line_data","x":5,"y":5.1969,"coef":0.9465,"int":0.4644,"_row":21},{"data":"line_data","x":5.25,"y":5.4335,"coef":0.9465,"int":0.4644,"_row":22},{"data":"line_data","x":5.5,"y":5.6701,"coef":0.9465,"int":0.4644,"_row":23},{"data":"line_data","x":5.75,"y":5.9068,"coef":0.9465,"int":0.4644,"_row":24},{"data":"line_data","x":6,"y":6.1434,"coef":0.9465,"int":0.4644,"_row":25},{"data":"line_data","x":6.25,"y":6.38,"coef":0.9465,"int":0.4644,"_row":26},{"data":"line_data","x":6.5,"y":6.6166,"coef":0.9465,"int":0.4644,"_row":27},{"data":"line_data","x":6.75,"y":6.8533,"coef":0.9465,"int":0.4644,"_row":28},{"data":"line_data","x":7,"y":7.0899,"coef":0.9465,"int":0.4644,"_row":29},{"data":"line_data","x":7.25,"y":7.3265,"coef":0.9465,"int":0.4644,"_row":30},{"data":"line_data","x":7.5,"y":7.5631,"coef":0.9465,"int":0.4644,"_row":31},{"data":"line_data","x":7.75,"y":7.7997,"coef":0.9465,"int":0.4644,"_row":32},{"data":"line_data","x":8,"y":8.0364,"coef":0.9465,"int":0.4644,"_row":33},{"data":"line_data","x":8.25,"y":8.273,"coef":0.9465,"int":0.4644,"_row":34},{"data":"line_data","x":8.5,"y":8.5096,"coef":0.9465,"int":0.4644,"_row":35},{"data":"line_data","x":8.75,"y":8.7462,"coef":0.9465,"int":0.4644,"_row":36},{"data":"line_data","x":9,"y":8.9829,"coef":0.9465,"int":0.4644,"_row":37},{"data":"line_data","x":9.25,"y":9.2195,"coef":0.9465,"int":0.4644,"_row":38},{"data":"line_data","x":9.5,"y":9.4561,"coef":0.9465,"int":0.4644,"_row":39},{"data":"line_data","x":9.75,"y":9.6927,"coef":0.9465,"int":0.4644,"_row":40},{"data":"line_data","x":10,"y":9.9293,"coef":0.9465,"int":0.4644,"_row":41},{"data":"line_data","x":10.25,"y":10.166,"coef":0.9465,"int":0.4644,"_row":42},{"data":"line_data","x":10.5,"y":10.4026,"coef":0.9465,"int":0.4644,"_row":43},{"data":"line_data","x":10.75,"y":10.6392,"coef":0.9465,"int":0.4644,"_row":44},{"data":"line_data","x":11,"y":10.8758,"coef":0.9465,"int":0.4644,"_row":45},{"data":"line_data","x":11.25,"y":11.1125,"coef":0.9465,"int":0.4644,"_row":46},{"data":"line_data","x":11.5,"y":11.3491,"coef":0.9465,"int":0.4644,"_row":47},{"data":"line_data","x":11.75,"y":11.5857,"coef":0.9465,"int":0.4644,"_row":48},{"data":"line_data","x":12,"y":11.8223,"coef":0.9465,"int":0.4644,"_row":49},{"data":"line_data","x":12.25,"y":12.0589,"coef":0.9465,"int":0.4644,"_row":50},{"data":"line_data","x":12.5,"y":12.2956,"coef":0.9465,"int":0.4644,"_row":51},{"data":"line_data","x":12.75,"y":12.5322,"coef":0.9465,"int":0.4644,"_row":52},{"data":"line_data","x":13,"y":12.7688,"coef":0.9465,"int":0.4644,"_row":53},{"data":"line_data","x":13.25,"y":13.0054,"coef":0.9465,"int":0.4644,"_row":54},{"data":"line_data","x":13.5,"y":13.2421,"coef":0.9465,"int":0.4644,"_row":55},{"data":"line_data","x":13.75,"y":13.4787,"coef":0.9465,"int":0.4644,"_row":56},{"data":"line_data","x":14,"y":13.7153,"coef":0.9465,"int":0.4644,"_row":57},{"data":"line_data","x":14.25,"y":13.9519,"coef":0.9465,"int":0.4644,"_row":58},{"data":"line_data","x":14.5,"y":14.1886,"coef":0.9465,"int":0.4644,"_row":59},{"data":"line_data","x":14.75,"y":14.4252,"coef":0.9465,"int":0.4644,"_row":60},{"data":"line_data","x":15,"y":14.6618,"coef":0.9465,"int":0.4644,"_row":61},{"data":"line_data","x":15.25,"y":14.8984,"coef":0.9465,"int":0.4644,"_row":62},{"data":"line_data","x":15.5,"y":15.135,"coef":0.9465,"int":0.4644,"_row":63},{"data":"line_data","x":15.75,"y":15.3717,"coef":0.9465,"int":0.4644,"_row":64},{"data":"line_data","x":16,"y":15.6083,"coef":0.9465,"int":0.4644,"_row":65},{"data":"line_data","x":16.25,"y":15.8449,"coef":0.9465,"int":0.4644,"_row":66},{"data":"line_data","x":16.5,"y":16.0815,"coef":0.9465,"int":0.4644,"_row":67},{"data":"line_data","x":16.75,"y":16.3182,"coef":0.9465,"int":0.4644,"_row":68},{"data":"line_data","x":17,"y":16.5548,"coef":0.9465,"int":0.4644,"_row":69},{"data":"line_data","x":17.25,"y":16.7914,"coef":0.9465,"int":0.4644,"_row":70},{"data":"line_data","x":17.5,"y":17.028,"coef":0.9465,"int":0.4644,"_row":71},{"data":"line_data","x":17.75,"y":17.2646,"coef":0.9465,"int":0.4644,"_row":72},{"data":"line_data","x":18,"y":17.5013,"coef":0.9465,"int":0.4644,"_row":73},{"data":"line_data","x":18.25,"y":17.7379,"coef":0.9465,"int":0.4644,"_row":74},{"data":"line_data","x":18.5,"y":17.9745,"coef":0.9465,"int":0.4644,"_row":75},{"data":"line_data","x":18.75,"y":18.2111,"coef":0.9465,"int":0.4644,"_row":76},{"data":"line_data","x":19,"y":18.4478,"coef":0.9465,"int":0.4644,"_row":77},{"data":"line_data","x":19.25,"y":18.6844,"coef":0.9465,"int":0.4644,"_row":78},{"data":"line_data","x":19.5,"y":18.921,"coef":0.9465,"int":0.4644,"_row":79},{"data":"line_data","x":19.75,"y":19.1576,"coef":0.9465,"int":0.4644,"_row":80},{"data":"line_data","x":20,"y":19.3942,"coef":0.9465,"int":0.4644,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"Time","y_range":[-1.97678526239998,23.01679417417655],"y_lab":"Sales","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"Sales Over Time","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details>
</div>
<div class="section level3">
<h3 id="color-customization">Color Customization<a class="anchor" aria-label="anchor" href="#color-customization"></a>
</h3>
<p>There are numerous visualization parameters too change the appearance
of the plot and the most notable are the changes you can make to the
colors. These options include:</p>
<ol style="list-style-type: decimal">
<li><p><strong>drawn_line_color:</strong> This parameter changes the
color of the lines that the user draws on the plot.</p></li>
<li><p><strong>true_line_color:</strong> This parameter changes the
color of the actual line and optionally confidence interval region in
the plot, which is revealed when the user clicks the â€˜Show True Lineâ€™
button.</p></li>
<li><p><strong>draw_region_color:</strong> This parameter changes the
color of the drawing region, which is the area that shows the userâ€™s
progress as they draw the line.</p></li>
</ol>
<p>The default <code>drawn_line_color</code> and
<code>true_line_color</code> are â€œsteelblueâ€ letâ€™s generate a confidence
interval to truly showcase how the color changes. Remember, you must
generate the confidence interval in the data generator first to display
it in the <code><a href="../reference/drawr.html">drawr()</a></code> function. In this example we will use a
â€œredâ€ drawing color and a â€œpurpleâ€ true_line/conf_int color. Remember to
see the true line, you must complete complete the graph (shown by the
yellow progress region). Try for yourself in the example below!</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Generate new data with confidence interval</span></span>
<span><span class="va">conf_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/linearDataGen.html">linearDataGen</a></span><span class="op">(</span>y_int <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                      slope <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                      sigma <span class="op">=</span> <span class="fl">2.5</span>,</span>
<span>                      N <span class="op">=</span> <span class="fl">20</span>,</span>
<span>                      conf_int <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create plot with new color paramaters and display confidence interval region</span></span>
<span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">conf_data</span>,</span>
<span>      drawn_line_color <span class="op">=</span> <span class="st">"red"</span>,</span>
<span>      true_line_color <span class="op">=</span> <span class="st">"purple"</span>,</span>
<span>      conf_int <span class="op">=</span> <span class="cn">T</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-7531f021030c44f57ef2" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-7531f021030c44f57ef2">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":1.0662,"_row":1},{"data":"point_data","x":1.0526,"y":0.315,"_row":2},{"data":"point_data","x":2.1053,"y":4.3431,"_row":3},{"data":"point_data","x":3.1579,"y":5.3532,"_row":4},{"data":"point_data","x":4.2105,"y":6.2645,"_row":5},{"data":"point_data","x":5.2632,"y":6.9848,"_row":6},{"data":"point_data","x":6.3158,"y":7.7006,"_row":7},{"data":"point_data","x":7.3684,"y":7.2136,"_row":8},{"data":"point_data","x":8.4211,"y":7.6561,"_row":9},{"data":"point_data","x":9.4737,"y":8.5225,"_row":10},{"data":"point_data","x":10.5263,"y":8.7895,"_row":11},{"data":"point_data","x":11.5789,"y":11.0592,"_row":12},{"data":"point_data","x":12.6316,"y":9.4681,"_row":13},{"data":"point_data","x":13.6842,"y":19.1066,"_row":14},{"data":"point_data","x":14.7368,"y":17.7567,"_row":15},{"data":"point_data","x":15.7895,"y":12.9817,"_row":16},{"data":"point_data","x":16.8421,"y":15.8349,"_row":17},{"data":"point_data","x":17.8947,"y":16.7281,"_row":18},{"data":"point_data","x":18.9474,"y":20.8973,"_row":19},{"data":"point_data","x":20,"y":19.7916,"_row":20}],"line_data":[{"data":"line_data","x":0,"y":1.1049,"coef":0.9287,"int":1.1049,"lower_bound":-0.8184,"upper_bound":3.0282,"_row":1},{"data":"line_data","x":1.0526,"y":2.0824,"coef":0.9287,"int":1.1049,"lower_bound":0.3048,"upper_bound":3.8601,"_row":2},{"data":"line_data","x":2.1053,"y":3.06,"coef":0.9287,"int":1.1049,"lower_bound":1.4227,"upper_bound":4.6973,"_row":3},{"data":"line_data","x":3.1579,"y":4.0376,"coef":0.9287,"int":1.1049,"lower_bound":2.5338,"upper_bound":5.5413,"_row":4},{"data":"line_data","x":4.2105,"y":5.0151,"coef":0.9287,"int":1.1049,"lower_bound":3.636,"upper_bound":6.3942,"_row":5},{"data":"line_data","x":5.2632,"y":5.9927,"coef":0.9287,"int":1.1049,"lower_bound":4.7268,"upper_bound":7.2585,"_row":6},{"data":"line_data","x":6.3158,"y":6.9702,"coef":0.9287,"int":1.1049,"lower_bound":5.8028,"upper_bound":8.1376,"_row":7},{"data":"line_data","x":7.3684,"y":7.9478,"coef":0.9287,"int":1.1049,"lower_bound":6.8601,"upper_bound":9.0355,"_row":8},{"data":"line_data","x":8.4211,"y":8.9253,"coef":0.9287,"int":1.1049,"lower_bound":7.8942,"upper_bound":9.9565,"_row":9},{"data":"line_data","x":9.4737,"y":9.9029,"coef":0.9287,"int":1.1049,"lower_bound":8.9012,"upper_bound":10.9046,"_row":10},{"data":"line_data","x":10.5263,"y":10.8804,"coef":0.9287,"int":1.1049,"lower_bound":9.8787,"upper_bound":11.8821,"_row":11},{"data":"line_data","x":11.5789,"y":11.858,"coef":0.9287,"int":1.1049,"lower_bound":10.8268,"upper_bound":12.8892,"_row":12},{"data":"line_data","x":12.6316,"y":12.8355,"coef":0.9287,"int":1.1049,"lower_bound":11.7478,"upper_bound":13.9233,"_row":13},{"data":"line_data","x":13.6842,"y":13.8131,"coef":0.9287,"int":1.1049,"lower_bound":12.6457,"upper_bound":14.9805,"_row":14},{"data":"line_data","x":14.7368,"y":14.7907,"coef":0.9287,"int":1.1049,"lower_bound":13.5248,"upper_bound":16.0565,"_row":15},{"data":"line_data","x":15.7895,"y":15.7682,"coef":0.9287,"int":1.1049,"lower_bound":14.3891,"upper_bound":17.1473,"_row":16},{"data":"line_data","x":16.8421,"y":16.7458,"coef":0.9287,"int":1.1049,"lower_bound":15.242,"upper_bound":18.2496,"_row":17},{"data":"line_data","x":17.8947,"y":17.7233,"coef":0.9287,"int":1.1049,"lower_bound":16.086,"upper_bound":19.3606,"_row":18},{"data":"line_data","x":18.9474,"y":18.7009,"coef":0.9287,"int":1.1049,"lower_bound":16.9233,"upper_bound":20.4785,"_row":19},{"data":"line_data","x":20,"y":19.6784,"coef":0.9287,"int":1.1049,"lower_bound":17.7551,"upper_bound":21.6017,"_row":20}],"lower_bound":[{"x":0,"y":-0.8184,"_row":1},{"x":1.0526,"y":0.3048,"_row":2},{"x":2.1053,"y":1.4227,"_row":3},{"x":3.1579,"y":2.5338,"_row":4},{"x":4.2105,"y":3.636,"_row":5},{"x":5.2632,"y":4.7268,"_row":6},{"x":6.3158,"y":5.8028,"_row":7},{"x":7.3684,"y":6.8601,"_row":8},{"x":8.4211,"y":7.8942,"_row":9},{"x":9.4737,"y":8.9012,"_row":10},{"x":10.5263,"y":9.8787,"_row":11},{"x":11.5789,"y":10.8268,"_row":12},{"x":12.6316,"y":11.7478,"_row":13},{"x":13.6842,"y":12.6457,"_row":14},{"x":14.7368,"y":13.5248,"_row":15},{"x":15.7895,"y":14.3891,"_row":16},{"x":16.8421,"y":15.242,"_row":17},{"x":17.8947,"y":16.086,"_row":18},{"x":18.9474,"y":16.9233,"_row":19},{"x":20,"y":17.7551,"_row":20}],"upper_bound":[{"x":0,"y":3.0282,"_row":1},{"x":1.0526,"y":3.8601,"_row":2},{"x":2.1053,"y":4.6973,"_row":3},{"x":3.1579,"y":5.5413,"_row":4},{"x":4.2105,"y":6.3942,"_row":5},{"x":5.2632,"y":7.2585,"_row":6},{"x":6.3158,"y":8.1376,"_row":7},{"x":7.3684,"y":9.0355,"_row":8},{"x":8.4211,"y":9.9565,"_row":9},{"x":9.4737,"y":10.9046,"_row":10},{"x":10.5263,"y":11.8821,"_row":11},{"x":11.5789,"y":12.8892,"_row":12},{"x":12.6316,"y":13.9233,"_row":13},{"x":13.6842,"y":14.9805,"_row":14},{"x":14.7368,"y":16.0565,"_row":15},{"x":15.7895,"y":17.1473,"_row":16},{"x":16.8421,"y":18.2496,"_row":17},{"x":17.8947,"y":19.3606,"_row":18},{"x":18.9474,"y":20.4785,"_row":19},{"x":20,"y":21.6017,"_row":20}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-0.7141635458046462,21.92639763416476],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"red","data_line_color":"purple","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":true},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><p>Changing the <code>draw_region_color</code> is also an option. This
can be changed to any color and can even be removed by choosing â€œwhiteâ€
or NULL, however this is not recommended as the progress region has been
made to help the user when completing the line. If removing the draw
region, it is recommended to use <code>show_tooltip = TRUE</code> so the
user has a way to know if they have skipped over a portion of the line.
This tooltip will display progress when hovering over the area that has
not yet been drawn over with the connected line.</p>
<details><summary>
Example with different draw_region_color
</summary><div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>,</span>
<span>      draw_region_color <span class="op">=</span> <span class="st">"green"</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-983315589fed18d622a7" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-983315589fed18d622a7">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.4644,"coef":0.9465,"int":0.4644,"_row":1},{"data":"line_data","x":0.25,"y":0.7011,"coef":0.9465,"int":0.4644,"_row":2},{"data":"line_data","x":0.5,"y":0.9377,"coef":0.9465,"int":0.4644,"_row":3},{"data":"line_data","x":0.75,"y":1.1743,"coef":0.9465,"int":0.4644,"_row":4},{"data":"line_data","x":1,"y":1.4109,"coef":0.9465,"int":0.4644,"_row":5},{"data":"line_data","x":1.25,"y":1.6476,"coef":0.9465,"int":0.4644,"_row":6},{"data":"line_data","x":1.5,"y":1.8842,"coef":0.9465,"int":0.4644,"_row":7},{"data":"line_data","x":1.75,"y":2.1208,"coef":0.9465,"int":0.4644,"_row":8},{"data":"line_data","x":2,"y":2.3574,"coef":0.9465,"int":0.4644,"_row":9},{"data":"line_data","x":2.25,"y":2.594,"coef":0.9465,"int":0.4644,"_row":10},{"data":"line_data","x":2.5,"y":2.8307,"coef":0.9465,"int":0.4644,"_row":11},{"data":"line_data","x":2.75,"y":3.0673,"coef":0.9465,"int":0.4644,"_row":12},{"data":"line_data","x":3,"y":3.3039,"coef":0.9465,"int":0.4644,"_row":13},{"data":"line_data","x":3.25,"y":3.5405,"coef":0.9465,"int":0.4644,"_row":14},{"data":"line_data","x":3.5,"y":3.7772,"coef":0.9465,"int":0.4644,"_row":15},{"data":"line_data","x":3.75,"y":4.0138,"coef":0.9465,"int":0.4644,"_row":16},{"data":"line_data","x":4,"y":4.2504,"coef":0.9465,"int":0.4644,"_row":17},{"data":"line_data","x":4.25,"y":4.487,"coef":0.9465,"int":0.4644,"_row":18},{"data":"line_data","x":4.5,"y":4.7236,"coef":0.9465,"int":0.4644,"_row":19},{"data":"line_data","x":4.75,"y":4.9603,"coef":0.9465,"int":0.4644,"_row":20},{"data":"line_data","x":5,"y":5.1969,"coef":0.9465,"int":0.4644,"_row":21},{"data":"line_data","x":5.25,"y":5.4335,"coef":0.9465,"int":0.4644,"_row":22},{"data":"line_data","x":5.5,"y":5.6701,"coef":0.9465,"int":0.4644,"_row":23},{"data":"line_data","x":5.75,"y":5.9068,"coef":0.9465,"int":0.4644,"_row":24},{"data":"line_data","x":6,"y":6.1434,"coef":0.9465,"int":0.4644,"_row":25},{"data":"line_data","x":6.25,"y":6.38,"coef":0.9465,"int":0.4644,"_row":26},{"data":"line_data","x":6.5,"y":6.6166,"coef":0.9465,"int":0.4644,"_row":27},{"data":"line_data","x":6.75,"y":6.8533,"coef":0.9465,"int":0.4644,"_row":28},{"data":"line_data","x":7,"y":7.0899,"coef":0.9465,"int":0.4644,"_row":29},{"data":"line_data","x":7.25,"y":7.3265,"coef":0.9465,"int":0.4644,"_row":30},{"data":"line_data","x":7.5,"y":7.5631,"coef":0.9465,"int":0.4644,"_row":31},{"data":"line_data","x":7.75,"y":7.7997,"coef":0.9465,"int":0.4644,"_row":32},{"data":"line_data","x":8,"y":8.0364,"coef":0.9465,"int":0.4644,"_row":33},{"data":"line_data","x":8.25,"y":8.273,"coef":0.9465,"int":0.4644,"_row":34},{"data":"line_data","x":8.5,"y":8.5096,"coef":0.9465,"int":0.4644,"_row":35},{"data":"line_data","x":8.75,"y":8.7462,"coef":0.9465,"int":0.4644,"_row":36},{"data":"line_data","x":9,"y":8.9829,"coef":0.9465,"int":0.4644,"_row":37},{"data":"line_data","x":9.25,"y":9.2195,"coef":0.9465,"int":0.4644,"_row":38},{"data":"line_data","x":9.5,"y":9.4561,"coef":0.9465,"int":0.4644,"_row":39},{"data":"line_data","x":9.75,"y":9.6927,"coef":0.9465,"int":0.4644,"_row":40},{"data":"line_data","x":10,"y":9.9293,"coef":0.9465,"int":0.4644,"_row":41},{"data":"line_data","x":10.25,"y":10.166,"coef":0.9465,"int":0.4644,"_row":42},{"data":"line_data","x":10.5,"y":10.4026,"coef":0.9465,"int":0.4644,"_row":43},{"data":"line_data","x":10.75,"y":10.6392,"coef":0.9465,"int":0.4644,"_row":44},{"data":"line_data","x":11,"y":10.8758,"coef":0.9465,"int":0.4644,"_row":45},{"data":"line_data","x":11.25,"y":11.1125,"coef":0.9465,"int":0.4644,"_row":46},{"data":"line_data","x":11.5,"y":11.3491,"coef":0.9465,"int":0.4644,"_row":47},{"data":"line_data","x":11.75,"y":11.5857,"coef":0.9465,"int":0.4644,"_row":48},{"data":"line_data","x":12,"y":11.8223,"coef":0.9465,"int":0.4644,"_row":49},{"data":"line_data","x":12.25,"y":12.0589,"coef":0.9465,"int":0.4644,"_row":50},{"data":"line_data","x":12.5,"y":12.2956,"coef":0.9465,"int":0.4644,"_row":51},{"data":"line_data","x":12.75,"y":12.5322,"coef":0.9465,"int":0.4644,"_row":52},{"data":"line_data","x":13,"y":12.7688,"coef":0.9465,"int":0.4644,"_row":53},{"data":"line_data","x":13.25,"y":13.0054,"coef":0.9465,"int":0.4644,"_row":54},{"data":"line_data","x":13.5,"y":13.2421,"coef":0.9465,"int":0.4644,"_row":55},{"data":"line_data","x":13.75,"y":13.4787,"coef":0.9465,"int":0.4644,"_row":56},{"data":"line_data","x":14,"y":13.7153,"coef":0.9465,"int":0.4644,"_row":57},{"data":"line_data","x":14.25,"y":13.9519,"coef":0.9465,"int":0.4644,"_row":58},{"data":"line_data","x":14.5,"y":14.1886,"coef":0.9465,"int":0.4644,"_row":59},{"data":"line_data","x":14.75,"y":14.4252,"coef":0.9465,"int":0.4644,"_row":60},{"data":"line_data","x":15,"y":14.6618,"coef":0.9465,"int":0.4644,"_row":61},{"data":"line_data","x":15.25,"y":14.8984,"coef":0.9465,"int":0.4644,"_row":62},{"data":"line_data","x":15.5,"y":15.135,"coef":0.9465,"int":0.4644,"_row":63},{"data":"line_data","x":15.75,"y":15.3717,"coef":0.9465,"int":0.4644,"_row":64},{"data":"line_data","x":16,"y":15.6083,"coef":0.9465,"int":0.4644,"_row":65},{"data":"line_data","x":16.25,"y":15.8449,"coef":0.9465,"int":0.4644,"_row":66},{"data":"line_data","x":16.5,"y":16.0815,"coef":0.9465,"int":0.4644,"_row":67},{"data":"line_data","x":16.75,"y":16.3182,"coef":0.9465,"int":0.4644,"_row":68},{"data":"line_data","x":17,"y":16.5548,"coef":0.9465,"int":0.4644,"_row":69},{"data":"line_data","x":17.25,"y":16.7914,"coef":0.9465,"int":0.4644,"_row":70},{"data":"line_data","x":17.5,"y":17.028,"coef":0.9465,"int":0.4644,"_row":71},{"data":"line_data","x":17.75,"y":17.2646,"coef":0.9465,"int":0.4644,"_row":72},{"data":"line_data","x":18,"y":17.5013,"coef":0.9465,"int":0.4644,"_row":73},{"data":"line_data","x":18.25,"y":17.7379,"coef":0.9465,"int":0.4644,"_row":74},{"data":"line_data","x":18.5,"y":17.9745,"coef":0.9465,"int":0.4644,"_row":75},{"data":"line_data","x":18.75,"y":18.2111,"coef":0.9465,"int":0.4644,"_row":76},{"data":"line_data","x":19,"y":18.4478,"coef":0.9465,"int":0.4644,"_row":77},{"data":"line_data","x":19.25,"y":18.6844,"coef":0.9465,"int":0.4644,"_row":78},{"data":"line_data","x":19.5,"y":18.921,"coef":0.9465,"int":0.4644,"_row":79},{"data":"line_data","x":19.75,"y":19.1576,"coef":0.9465,"int":0.4644,"_row":80},{"data":"line_data","x":20,"y":19.3942,"coef":0.9465,"int":0.4644,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-1.97678526239998,23.01679417417655],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"green","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><details><summary>
Example with draw region removed
</summary><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>,</span>
<span>      draw_region_color <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>      show_tooltip <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-6f1d8b9e786d9d3fe28d" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-6f1d8b9e786d9d3fe28d">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.4644,"coef":0.9465,"int":0.4644,"_row":1},{"data":"line_data","x":0.25,"y":0.7011,"coef":0.9465,"int":0.4644,"_row":2},{"data":"line_data","x":0.5,"y":0.9377,"coef":0.9465,"int":0.4644,"_row":3},{"data":"line_data","x":0.75,"y":1.1743,"coef":0.9465,"int":0.4644,"_row":4},{"data":"line_data","x":1,"y":1.4109,"coef":0.9465,"int":0.4644,"_row":5},{"data":"line_data","x":1.25,"y":1.6476,"coef":0.9465,"int":0.4644,"_row":6},{"data":"line_data","x":1.5,"y":1.8842,"coef":0.9465,"int":0.4644,"_row":7},{"data":"line_data","x":1.75,"y":2.1208,"coef":0.9465,"int":0.4644,"_row":8},{"data":"line_data","x":2,"y":2.3574,"coef":0.9465,"int":0.4644,"_row":9},{"data":"line_data","x":2.25,"y":2.594,"coef":0.9465,"int":0.4644,"_row":10},{"data":"line_data","x":2.5,"y":2.8307,"coef":0.9465,"int":0.4644,"_row":11},{"data":"line_data","x":2.75,"y":3.0673,"coef":0.9465,"int":0.4644,"_row":12},{"data":"line_data","x":3,"y":3.3039,"coef":0.9465,"int":0.4644,"_row":13},{"data":"line_data","x":3.25,"y":3.5405,"coef":0.9465,"int":0.4644,"_row":14},{"data":"line_data","x":3.5,"y":3.7772,"coef":0.9465,"int":0.4644,"_row":15},{"data":"line_data","x":3.75,"y":4.0138,"coef":0.9465,"int":0.4644,"_row":16},{"data":"line_data","x":4,"y":4.2504,"coef":0.9465,"int":0.4644,"_row":17},{"data":"line_data","x":4.25,"y":4.487,"coef":0.9465,"int":0.4644,"_row":18},{"data":"line_data","x":4.5,"y":4.7236,"coef":0.9465,"int":0.4644,"_row":19},{"data":"line_data","x":4.75,"y":4.9603,"coef":0.9465,"int":0.4644,"_row":20},{"data":"line_data","x":5,"y":5.1969,"coef":0.9465,"int":0.4644,"_row":21},{"data":"line_data","x":5.25,"y":5.4335,"coef":0.9465,"int":0.4644,"_row":22},{"data":"line_data","x":5.5,"y":5.6701,"coef":0.9465,"int":0.4644,"_row":23},{"data":"line_data","x":5.75,"y":5.9068,"coef":0.9465,"int":0.4644,"_row":24},{"data":"line_data","x":6,"y":6.1434,"coef":0.9465,"int":0.4644,"_row":25},{"data":"line_data","x":6.25,"y":6.38,"coef":0.9465,"int":0.4644,"_row":26},{"data":"line_data","x":6.5,"y":6.6166,"coef":0.9465,"int":0.4644,"_row":27},{"data":"line_data","x":6.75,"y":6.8533,"coef":0.9465,"int":0.4644,"_row":28},{"data":"line_data","x":7,"y":7.0899,"coef":0.9465,"int":0.4644,"_row":29},{"data":"line_data","x":7.25,"y":7.3265,"coef":0.9465,"int":0.4644,"_row":30},{"data":"line_data","x":7.5,"y":7.5631,"coef":0.9465,"int":0.4644,"_row":31},{"data":"line_data","x":7.75,"y":7.7997,"coef":0.9465,"int":0.4644,"_row":32},{"data":"line_data","x":8,"y":8.0364,"coef":0.9465,"int":0.4644,"_row":33},{"data":"line_data","x":8.25,"y":8.273,"coef":0.9465,"int":0.4644,"_row":34},{"data":"line_data","x":8.5,"y":8.5096,"coef":0.9465,"int":0.4644,"_row":35},{"data":"line_data","x":8.75,"y":8.7462,"coef":0.9465,"int":0.4644,"_row":36},{"data":"line_data","x":9,"y":8.9829,"coef":0.9465,"int":0.4644,"_row":37},{"data":"line_data","x":9.25,"y":9.2195,"coef":0.9465,"int":0.4644,"_row":38},{"data":"line_data","x":9.5,"y":9.4561,"coef":0.9465,"int":0.4644,"_row":39},{"data":"line_data","x":9.75,"y":9.6927,"coef":0.9465,"int":0.4644,"_row":40},{"data":"line_data","x":10,"y":9.9293,"coef":0.9465,"int":0.4644,"_row":41},{"data":"line_data","x":10.25,"y":10.166,"coef":0.9465,"int":0.4644,"_row":42},{"data":"line_data","x":10.5,"y":10.4026,"coef":0.9465,"int":0.4644,"_row":43},{"data":"line_data","x":10.75,"y":10.6392,"coef":0.9465,"int":0.4644,"_row":44},{"data":"line_data","x":11,"y":10.8758,"coef":0.9465,"int":0.4644,"_row":45},{"data":"line_data","x":11.25,"y":11.1125,"coef":0.9465,"int":0.4644,"_row":46},{"data":"line_data","x":11.5,"y":11.3491,"coef":0.9465,"int":0.4644,"_row":47},{"data":"line_data","x":11.75,"y":11.5857,"coef":0.9465,"int":0.4644,"_row":48},{"data":"line_data","x":12,"y":11.8223,"coef":0.9465,"int":0.4644,"_row":49},{"data":"line_data","x":12.25,"y":12.0589,"coef":0.9465,"int":0.4644,"_row":50},{"data":"line_data","x":12.5,"y":12.2956,"coef":0.9465,"int":0.4644,"_row":51},{"data":"line_data","x":12.75,"y":12.5322,"coef":0.9465,"int":0.4644,"_row":52},{"data":"line_data","x":13,"y":12.7688,"coef":0.9465,"int":0.4644,"_row":53},{"data":"line_data","x":13.25,"y":13.0054,"coef":0.9465,"int":0.4644,"_row":54},{"data":"line_data","x":13.5,"y":13.2421,"coef":0.9465,"int":0.4644,"_row":55},{"data":"line_data","x":13.75,"y":13.4787,"coef":0.9465,"int":0.4644,"_row":56},{"data":"line_data","x":14,"y":13.7153,"coef":0.9465,"int":0.4644,"_row":57},{"data":"line_data","x":14.25,"y":13.9519,"coef":0.9465,"int":0.4644,"_row":58},{"data":"line_data","x":14.5,"y":14.1886,"coef":0.9465,"int":0.4644,"_row":59},{"data":"line_data","x":14.75,"y":14.4252,"coef":0.9465,"int":0.4644,"_row":60},{"data":"line_data","x":15,"y":14.6618,"coef":0.9465,"int":0.4644,"_row":61},{"data":"line_data","x":15.25,"y":14.8984,"coef":0.9465,"int":0.4644,"_row":62},{"data":"line_data","x":15.5,"y":15.135,"coef":0.9465,"int":0.4644,"_row":63},{"data":"line_data","x":15.75,"y":15.3717,"coef":0.9465,"int":0.4644,"_row":64},{"data":"line_data","x":16,"y":15.6083,"coef":0.9465,"int":0.4644,"_row":65},{"data":"line_data","x":16.25,"y":15.8449,"coef":0.9465,"int":0.4644,"_row":66},{"data":"line_data","x":16.5,"y":16.0815,"coef":0.9465,"int":0.4644,"_row":67},{"data":"line_data","x":16.75,"y":16.3182,"coef":0.9465,"int":0.4644,"_row":68},{"data":"line_data","x":17,"y":16.5548,"coef":0.9465,"int":0.4644,"_row":69},{"data":"line_data","x":17.25,"y":16.7914,"coef":0.9465,"int":0.4644,"_row":70},{"data":"line_data","x":17.5,"y":17.028,"coef":0.9465,"int":0.4644,"_row":71},{"data":"line_data","x":17.75,"y":17.2646,"coef":0.9465,"int":0.4644,"_row":72},{"data":"line_data","x":18,"y":17.5013,"coef":0.9465,"int":0.4644,"_row":73},{"data":"line_data","x":18.25,"y":17.7379,"coef":0.9465,"int":0.4644,"_row":74},{"data":"line_data","x":18.5,"y":17.9745,"coef":0.9465,"int":0.4644,"_row":75},{"data":"line_data","x":18.75,"y":18.2111,"coef":0.9465,"int":0.4644,"_row":76},{"data":"line_data","x":19,"y":18.4478,"coef":0.9465,"int":0.4644,"_row":77},{"data":"line_data","x":19.25,"y":18.6844,"coef":0.9465,"int":0.4644,"_row":78},{"data":"line_data","x":19.5,"y":18.921,"coef":0.9465,"int":0.4644,"_row":79},{"data":"line_data","x":19.75,"y":19.1576,"coef":0.9465,"int":0.4644,"_row":80},{"data":"line_data","x":20,"y":19.3942,"coef":0.9465,"int":0.4644,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-1.97678526239998,23.01679417417655],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":null,"show_finished":true,"show_tooltip":true,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><p>For more information on other plot customization options, make sure
to go to the <code><a href="../reference/drawr.html">drawr()</a></code> function documentation.</p>
</div>
</div>
<div class="section level2">
<h2 id="understanding-and-using-the-buttons">Understanding and Using the Buttons<a class="anchor" aria-label="anchor" href="#understanding-and-using-the-buttons"></a>
</h2>
<p>The <code><a href="../reference/drawr.html">drawr()</a></code> function provides three main interactive
buttons: Reset, Download Data, and New Line/Stop Drawing. Hereâ€™s how you
can utilize them:</p>
<ul>
<li><p><strong>Reset Button:</strong> Clicking this button will erase
all user-drawn lines, and allows you to start over from
scratch.</p></li>
<li><p><strong>Download Data Button:</strong> This button downloads your
data as a JSON text file. The downloaded data includes both the original
line and any new lines drawn by the user. It will split the data in to
two section in the text file, making it easy to find. Just look for
â€œoriginal line:â€ for the original line and â€œnew lines:â€ for any added
lines.</p></li>
<li><p><strong>New Line/Stop Drawing Button:</strong> This button
toggles between adding a new line and extending the original line.
Clicking it once initiates the drawing of a new line, and the button
turns red. A second click, when the button reads â€œStop Drawingâ€,
concludes the new lineâ€™s drawing and reverts back to modifying the
original line. Keep in mind, once a new line is concluded, it can no
longer be edited.</p></li>
<li><p><strong>Line Color Picker:</strong> Upon clicking the â€œNew Lineâ€
button, a color palette appears under the buttons. This palette lets you
pick the color for your new line, enhancing visual distinction between
different lines. Simply click on the color block of your choice before
starting to draw or while drawing. The color palette will disappear once
a color is selected or when you click â€œStop Drawingâ€ or â€œResetâ€. If no
color is chosen the default will be â€œsteelblueâ€.</p></li>
</ul>
<p>Additionally, you can hide these buttons to reduce interface clutter
or when you donâ€™t need their functionality. This can be achieved by
setting the <code>hide_buttons = TRUE</code> parameter in the
<code><a href="../reference/drawr.html">drawr()</a></code> function.</p>
<p>Here is an example of how to hide the buttons in your output:</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>,</span>
<span>      hide_buttons <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-dcdfc64296f5794e54a4" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-dcdfc64296f5794e54a4">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.4644,"coef":0.9465,"int":0.4644,"_row":1},{"data":"line_data","x":0.25,"y":0.7011,"coef":0.9465,"int":0.4644,"_row":2},{"data":"line_data","x":0.5,"y":0.9377,"coef":0.9465,"int":0.4644,"_row":3},{"data":"line_data","x":0.75,"y":1.1743,"coef":0.9465,"int":0.4644,"_row":4},{"data":"line_data","x":1,"y":1.4109,"coef":0.9465,"int":0.4644,"_row":5},{"data":"line_data","x":1.25,"y":1.6476,"coef":0.9465,"int":0.4644,"_row":6},{"data":"line_data","x":1.5,"y":1.8842,"coef":0.9465,"int":0.4644,"_row":7},{"data":"line_data","x":1.75,"y":2.1208,"coef":0.9465,"int":0.4644,"_row":8},{"data":"line_data","x":2,"y":2.3574,"coef":0.9465,"int":0.4644,"_row":9},{"data":"line_data","x":2.25,"y":2.594,"coef":0.9465,"int":0.4644,"_row":10},{"data":"line_data","x":2.5,"y":2.8307,"coef":0.9465,"int":0.4644,"_row":11},{"data":"line_data","x":2.75,"y":3.0673,"coef":0.9465,"int":0.4644,"_row":12},{"data":"line_data","x":3,"y":3.3039,"coef":0.9465,"int":0.4644,"_row":13},{"data":"line_data","x":3.25,"y":3.5405,"coef":0.9465,"int":0.4644,"_row":14},{"data":"line_data","x":3.5,"y":3.7772,"coef":0.9465,"int":0.4644,"_row":15},{"data":"line_data","x":3.75,"y":4.0138,"coef":0.9465,"int":0.4644,"_row":16},{"data":"line_data","x":4,"y":4.2504,"coef":0.9465,"int":0.4644,"_row":17},{"data":"line_data","x":4.25,"y":4.487,"coef":0.9465,"int":0.4644,"_row":18},{"data":"line_data","x":4.5,"y":4.7236,"coef":0.9465,"int":0.4644,"_row":19},{"data":"line_data","x":4.75,"y":4.9603,"coef":0.9465,"int":0.4644,"_row":20},{"data":"line_data","x":5,"y":5.1969,"coef":0.9465,"int":0.4644,"_row":21},{"data":"line_data","x":5.25,"y":5.4335,"coef":0.9465,"int":0.4644,"_row":22},{"data":"line_data","x":5.5,"y":5.6701,"coef":0.9465,"int":0.4644,"_row":23},{"data":"line_data","x":5.75,"y":5.9068,"coef":0.9465,"int":0.4644,"_row":24},{"data":"line_data","x":6,"y":6.1434,"coef":0.9465,"int":0.4644,"_row":25},{"data":"line_data","x":6.25,"y":6.38,"coef":0.9465,"int":0.4644,"_row":26},{"data":"line_data","x":6.5,"y":6.6166,"coef":0.9465,"int":0.4644,"_row":27},{"data":"line_data","x":6.75,"y":6.8533,"coef":0.9465,"int":0.4644,"_row":28},{"data":"line_data","x":7,"y":7.0899,"coef":0.9465,"int":0.4644,"_row":29},{"data":"line_data","x":7.25,"y":7.3265,"coef":0.9465,"int":0.4644,"_row":30},{"data":"line_data","x":7.5,"y":7.5631,"coef":0.9465,"int":0.4644,"_row":31},{"data":"line_data","x":7.75,"y":7.7997,"coef":0.9465,"int":0.4644,"_row":32},{"data":"line_data","x":8,"y":8.0364,"coef":0.9465,"int":0.4644,"_row":33},{"data":"line_data","x":8.25,"y":8.273,"coef":0.9465,"int":0.4644,"_row":34},{"data":"line_data","x":8.5,"y":8.5096,"coef":0.9465,"int":0.4644,"_row":35},{"data":"line_data","x":8.75,"y":8.7462,"coef":0.9465,"int":0.4644,"_row":36},{"data":"line_data","x":9,"y":8.9829,"coef":0.9465,"int":0.4644,"_row":37},{"data":"line_data","x":9.25,"y":9.2195,"coef":0.9465,"int":0.4644,"_row":38},{"data":"line_data","x":9.5,"y":9.4561,"coef":0.9465,"int":0.4644,"_row":39},{"data":"line_data","x":9.75,"y":9.6927,"coef":0.9465,"int":0.4644,"_row":40},{"data":"line_data","x":10,"y":9.9293,"coef":0.9465,"int":0.4644,"_row":41},{"data":"line_data","x":10.25,"y":10.166,"coef":0.9465,"int":0.4644,"_row":42},{"data":"line_data","x":10.5,"y":10.4026,"coef":0.9465,"int":0.4644,"_row":43},{"data":"line_data","x":10.75,"y":10.6392,"coef":0.9465,"int":0.4644,"_row":44},{"data":"line_data","x":11,"y":10.8758,"coef":0.9465,"int":0.4644,"_row":45},{"data":"line_data","x":11.25,"y":11.1125,"coef":0.9465,"int":0.4644,"_row":46},{"data":"line_data","x":11.5,"y":11.3491,"coef":0.9465,"int":0.4644,"_row":47},{"data":"line_data","x":11.75,"y":11.5857,"coef":0.9465,"int":0.4644,"_row":48},{"data":"line_data","x":12,"y":11.8223,"coef":0.9465,"int":0.4644,"_row":49},{"data":"line_data","x":12.25,"y":12.0589,"coef":0.9465,"int":0.4644,"_row":50},{"data":"line_data","x":12.5,"y":12.2956,"coef":0.9465,"int":0.4644,"_row":51},{"data":"line_data","x":12.75,"y":12.5322,"coef":0.9465,"int":0.4644,"_row":52},{"data":"line_data","x":13,"y":12.7688,"coef":0.9465,"int":0.4644,"_row":53},{"data":"line_data","x":13.25,"y":13.0054,"coef":0.9465,"int":0.4644,"_row":54},{"data":"line_data","x":13.5,"y":13.2421,"coef":0.9465,"int":0.4644,"_row":55},{"data":"line_data","x":13.75,"y":13.4787,"coef":0.9465,"int":0.4644,"_row":56},{"data":"line_data","x":14,"y":13.7153,"coef":0.9465,"int":0.4644,"_row":57},{"data":"line_data","x":14.25,"y":13.9519,"coef":0.9465,"int":0.4644,"_row":58},{"data":"line_data","x":14.5,"y":14.1886,"coef":0.9465,"int":0.4644,"_row":59},{"data":"line_data","x":14.75,"y":14.4252,"coef":0.9465,"int":0.4644,"_row":60},{"data":"line_data","x":15,"y":14.6618,"coef":0.9465,"int":0.4644,"_row":61},{"data":"line_data","x":15.25,"y":14.8984,"coef":0.9465,"int":0.4644,"_row":62},{"data":"line_data","x":15.5,"y":15.135,"coef":0.9465,"int":0.4644,"_row":63},{"data":"line_data","x":15.75,"y":15.3717,"coef":0.9465,"int":0.4644,"_row":64},{"data":"line_data","x":16,"y":15.6083,"coef":0.9465,"int":0.4644,"_row":65},{"data":"line_data","x":16.25,"y":15.8449,"coef":0.9465,"int":0.4644,"_row":66},{"data":"line_data","x":16.5,"y":16.0815,"coef":0.9465,"int":0.4644,"_row":67},{"data":"line_data","x":16.75,"y":16.3182,"coef":0.9465,"int":0.4644,"_row":68},{"data":"line_data","x":17,"y":16.5548,"coef":0.9465,"int":0.4644,"_row":69},{"data":"line_data","x":17.25,"y":16.7914,"coef":0.9465,"int":0.4644,"_row":70},{"data":"line_data","x":17.5,"y":17.028,"coef":0.9465,"int":0.4644,"_row":71},{"data":"line_data","x":17.75,"y":17.2646,"coef":0.9465,"int":0.4644,"_row":72},{"data":"line_data","x":18,"y":17.5013,"coef":0.9465,"int":0.4644,"_row":73},{"data":"line_data","x":18.25,"y":17.7379,"coef":0.9465,"int":0.4644,"_row":74},{"data":"line_data","x":18.5,"y":17.9745,"coef":0.9465,"int":0.4644,"_row":75},{"data":"line_data","x":18.75,"y":18.2111,"coef":0.9465,"int":0.4644,"_row":76},{"data":"line_data","x":19,"y":18.4478,"coef":0.9465,"int":0.4644,"_row":77},{"data":"line_data","x":19.25,"y":18.6844,"coef":0.9465,"int":0.4644,"_row":78},{"data":"line_data","x":19.5,"y":18.921,"coef":0.9465,"int":0.4644,"_row":79},{"data":"line_data","x":19.75,"y":19.1576,"coef":0.9465,"int":0.4644,"_row":80},{"data":"line_data","x":20,"y":19.3942,"coef":0.9465,"int":0.4644,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":true,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-1.97678526239998,23.01679417417655],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><p>Now that you are familiar with the functionality of the buttons in
the <code><a href="../reference/drawr.html">drawr()</a></code> function, why not try them out for yourself in
the example below? In the following plot, use the â€œNew Line/Stop
Drawingâ€ button to start and stop drawing new lines, the â€œDownload Dataâ€
button to save your work, and the â€œResetâ€ button to clear all lines and
restart if you mess up.</p>
<details><summary>
See Example
</summary><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>,</span>
<span>      hide_buttons <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-873249b169eb6149d57e" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-873249b169eb6149d57e">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-0.8407,"_row":1},{"data":"point_data","x":0.6897,"y":0.3444,"_row":2},{"data":"point_data","x":1.3793,"y":3.7174,"_row":3},{"data":"point_data","x":2.069,"y":2.1747,"_row":4},{"data":"point_data","x":2.7586,"y":2.9526,"_row":5},{"data":"point_data","x":3.4483,"y":6.0209,"_row":6},{"data":"point_data","x":4.1379,"y":4.8293,"_row":7},{"data":"point_data","x":4.8276,"y":2.93,"_row":8},{"data":"point_data","x":5.5172,"y":4.487,"_row":9},{"data":"point_data","x":6.2069,"y":5.5384,"_row":10},{"data":"point_data","x":6.8966,"y":8.7327,"_row":11},{"data":"point_data","x":7.5862,"y":8.1259,"_row":12},{"data":"point_data","x":8.2759,"y":8.877,"_row":13},{"data":"point_data","x":8.9655,"y":9.1315,"_row":14},{"data":"point_data","x":9.6552,"y":8.8214,"_row":15},{"data":"point_data","x":10.3448,"y":13.0252,"_row":16},{"data":"point_data","x":11.0345,"y":11.7813,"_row":17},{"data":"point_data","x":11.7241,"y":8.7742,"_row":18},{"data":"point_data","x":12.4138,"y":13.4658,"_row":19},{"data":"point_data","x":13.1034,"y":12.3943,"_row":20},{"data":"point_data","x":13.7931,"y":12.1914,"_row":21},{"data":"point_data","x":14.4828,"y":14.1558,"_row":22},{"data":"point_data","x":15.1724,"y":13.6334,"_row":23},{"data":"point_data","x":15.8621,"y":14.7687,"_row":24},{"data":"point_data","x":16.5517,"y":15.6142,"_row":25},{"data":"point_data","x":17.2414,"y":14.7113,"_row":26},{"data":"point_data","x":17.931,"y":19.1877,"_row":27},{"data":"point_data","x":18.6207,"y":18.8507,"_row":28},{"data":"point_data","x":19.3103,"y":17.6031,"_row":29},{"data":"point_data","x":20,"y":21.8807,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.4644,"coef":0.9465,"int":0.4644,"_row":1},{"data":"line_data","x":0.25,"y":0.7011,"coef":0.9465,"int":0.4644,"_row":2},{"data":"line_data","x":0.5,"y":0.9377,"coef":0.9465,"int":0.4644,"_row":3},{"data":"line_data","x":0.75,"y":1.1743,"coef":0.9465,"int":0.4644,"_row":4},{"data":"line_data","x":1,"y":1.4109,"coef":0.9465,"int":0.4644,"_row":5},{"data":"line_data","x":1.25,"y":1.6476,"coef":0.9465,"int":0.4644,"_row":6},{"data":"line_data","x":1.5,"y":1.8842,"coef":0.9465,"int":0.4644,"_row":7},{"data":"line_data","x":1.75,"y":2.1208,"coef":0.9465,"int":0.4644,"_row":8},{"data":"line_data","x":2,"y":2.3574,"coef":0.9465,"int":0.4644,"_row":9},{"data":"line_data","x":2.25,"y":2.594,"coef":0.9465,"int":0.4644,"_row":10},{"data":"line_data","x":2.5,"y":2.8307,"coef":0.9465,"int":0.4644,"_row":11},{"data":"line_data","x":2.75,"y":3.0673,"coef":0.9465,"int":0.4644,"_row":12},{"data":"line_data","x":3,"y":3.3039,"coef":0.9465,"int":0.4644,"_row":13},{"data":"line_data","x":3.25,"y":3.5405,"coef":0.9465,"int":0.4644,"_row":14},{"data":"line_data","x":3.5,"y":3.7772,"coef":0.9465,"int":0.4644,"_row":15},{"data":"line_data","x":3.75,"y":4.0138,"coef":0.9465,"int":0.4644,"_row":16},{"data":"line_data","x":4,"y":4.2504,"coef":0.9465,"int":0.4644,"_row":17},{"data":"line_data","x":4.25,"y":4.487,"coef":0.9465,"int":0.4644,"_row":18},{"data":"line_data","x":4.5,"y":4.7236,"coef":0.9465,"int":0.4644,"_row":19},{"data":"line_data","x":4.75,"y":4.9603,"coef":0.9465,"int":0.4644,"_row":20},{"data":"line_data","x":5,"y":5.1969,"coef":0.9465,"int":0.4644,"_row":21},{"data":"line_data","x":5.25,"y":5.4335,"coef":0.9465,"int":0.4644,"_row":22},{"data":"line_data","x":5.5,"y":5.6701,"coef":0.9465,"int":0.4644,"_row":23},{"data":"line_data","x":5.75,"y":5.9068,"coef":0.9465,"int":0.4644,"_row":24},{"data":"line_data","x":6,"y":6.1434,"coef":0.9465,"int":0.4644,"_row":25},{"data":"line_data","x":6.25,"y":6.38,"coef":0.9465,"int":0.4644,"_row":26},{"data":"line_data","x":6.5,"y":6.6166,"coef":0.9465,"int":0.4644,"_row":27},{"data":"line_data","x":6.75,"y":6.8533,"coef":0.9465,"int":0.4644,"_row":28},{"data":"line_data","x":7,"y":7.0899,"coef":0.9465,"int":0.4644,"_row":29},{"data":"line_data","x":7.25,"y":7.3265,"coef":0.9465,"int":0.4644,"_row":30},{"data":"line_data","x":7.5,"y":7.5631,"coef":0.9465,"int":0.4644,"_row":31},{"data":"line_data","x":7.75,"y":7.7997,"coef":0.9465,"int":0.4644,"_row":32},{"data":"line_data","x":8,"y":8.0364,"coef":0.9465,"int":0.4644,"_row":33},{"data":"line_data","x":8.25,"y":8.273,"coef":0.9465,"int":0.4644,"_row":34},{"data":"line_data","x":8.5,"y":8.5096,"coef":0.9465,"int":0.4644,"_row":35},{"data":"line_data","x":8.75,"y":8.7462,"coef":0.9465,"int":0.4644,"_row":36},{"data":"line_data","x":9,"y":8.9829,"coef":0.9465,"int":0.4644,"_row":37},{"data":"line_data","x":9.25,"y":9.2195,"coef":0.9465,"int":0.4644,"_row":38},{"data":"line_data","x":9.5,"y":9.4561,"coef":0.9465,"int":0.4644,"_row":39},{"data":"line_data","x":9.75,"y":9.6927,"coef":0.9465,"int":0.4644,"_row":40},{"data":"line_data","x":10,"y":9.9293,"coef":0.9465,"int":0.4644,"_row":41},{"data":"line_data","x":10.25,"y":10.166,"coef":0.9465,"int":0.4644,"_row":42},{"data":"line_data","x":10.5,"y":10.4026,"coef":0.9465,"int":0.4644,"_row":43},{"data":"line_data","x":10.75,"y":10.6392,"coef":0.9465,"int":0.4644,"_row":44},{"data":"line_data","x":11,"y":10.8758,"coef":0.9465,"int":0.4644,"_row":45},{"data":"line_data","x":11.25,"y":11.1125,"coef":0.9465,"int":0.4644,"_row":46},{"data":"line_data","x":11.5,"y":11.3491,"coef":0.9465,"int":0.4644,"_row":47},{"data":"line_data","x":11.75,"y":11.5857,"coef":0.9465,"int":0.4644,"_row":48},{"data":"line_data","x":12,"y":11.8223,"coef":0.9465,"int":0.4644,"_row":49},{"data":"line_data","x":12.25,"y":12.0589,"coef":0.9465,"int":0.4644,"_row":50},{"data":"line_data","x":12.5,"y":12.2956,"coef":0.9465,"int":0.4644,"_row":51},{"data":"line_data","x":12.75,"y":12.5322,"coef":0.9465,"int":0.4644,"_row":52},{"data":"line_data","x":13,"y":12.7688,"coef":0.9465,"int":0.4644,"_row":53},{"data":"line_data","x":13.25,"y":13.0054,"coef":0.9465,"int":0.4644,"_row":54},{"data":"line_data","x":13.5,"y":13.2421,"coef":0.9465,"int":0.4644,"_row":55},{"data":"line_data","x":13.75,"y":13.4787,"coef":0.9465,"int":0.4644,"_row":56},{"data":"line_data","x":14,"y":13.7153,"coef":0.9465,"int":0.4644,"_row":57},{"data":"line_data","x":14.25,"y":13.9519,"coef":0.9465,"int":0.4644,"_row":58},{"data":"line_data","x":14.5,"y":14.1886,"coef":0.9465,"int":0.4644,"_row":59},{"data":"line_data","x":14.75,"y":14.4252,"coef":0.9465,"int":0.4644,"_row":60},{"data":"line_data","x":15,"y":14.6618,"coef":0.9465,"int":0.4644,"_row":61},{"data":"line_data","x":15.25,"y":14.8984,"coef":0.9465,"int":0.4644,"_row":62},{"data":"line_data","x":15.5,"y":15.135,"coef":0.9465,"int":0.4644,"_row":63},{"data":"line_data","x":15.75,"y":15.3717,"coef":0.9465,"int":0.4644,"_row":64},{"data":"line_data","x":16,"y":15.6083,"coef":0.9465,"int":0.4644,"_row":65},{"data":"line_data","x":16.25,"y":15.8449,"coef":0.9465,"int":0.4644,"_row":66},{"data":"line_data","x":16.5,"y":16.0815,"coef":0.9465,"int":0.4644,"_row":67},{"data":"line_data","x":16.75,"y":16.3182,"coef":0.9465,"int":0.4644,"_row":68},{"data":"line_data","x":17,"y":16.5548,"coef":0.9465,"int":0.4644,"_row":69},{"data":"line_data","x":17.25,"y":16.7914,"coef":0.9465,"int":0.4644,"_row":70},{"data":"line_data","x":17.5,"y":17.028,"coef":0.9465,"int":0.4644,"_row":71},{"data":"line_data","x":17.75,"y":17.2646,"coef":0.9465,"int":0.4644,"_row":72},{"data":"line_data","x":18,"y":17.5013,"coef":0.9465,"int":0.4644,"_row":73},{"data":"line_data","x":18.25,"y":17.7379,"coef":0.9465,"int":0.4644,"_row":74},{"data":"line_data","x":18.5,"y":17.9745,"coef":0.9465,"int":0.4644,"_row":75},{"data":"line_data","x":18.75,"y":18.2111,"coef":0.9465,"int":0.4644,"_row":76},{"data":"line_data","x":19,"y":18.4478,"coef":0.9465,"int":0.4644,"_row":77},{"data":"line_data","x":19.25,"y":18.6844,"coef":0.9465,"int":0.4644,"_row":78},{"data":"line_data","x":19.5,"y":18.921,"coef":0.9465,"int":0.4644,"_row":79},{"data":"line_data","x":19.75,"y":19.1576,"coef":0.9465,"int":0.4644,"_row":80},{"data":"line_data","x":20,"y":19.3942,"coef":0.9465,"int":0.4644,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-1.97678526239998,23.01679417417655],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","data_line_color":"steelblue","draw_region_color":"rgba(255,255,0,.8)","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 35 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.drawn_line_color || 'steelblue',\n  strokeWidth: 2.5,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\nif (typeof Shiny !== 'undefined') {\n  Shiny.addCustomMessageHandler('finishedColorAction', function(finished_color) {\n    if (finished_color !== \"steelblue\") {\n      finished_line = state.svg.select(\".finished_line\")\n      \n      default_line_attrs.stroke = finished_color\n      \n      finished_line\n        .style(\"stroke\", finished_color)\n        \n      if (state.conf_int) {\n        shaded_area = state.svg.select(\".shaded_area\")\n        let colorRGB = d3.rgb(finished_color);\n        \n        // Convert to HSL and increase saturation\n        let colorHSL = d3.hsl(colorRGB);\n        colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n        \n        // Convert back to RGB\n        let moreSaturatedColorRGB = d3.rgb(colorHSL);\n        let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n        shaded_area\n          .style(\"fill\", lighterColor)\n          \n          state.data_line_color = finished_color\n          options.data_line_color = finished_color\n      }\n    }\n  })\n  \n  Shiny.addCustomMessageHandler('drawColorAction', function(draw_color) {\n    if (draw_color !== \"steelblue\") {\n      user_line = state.svg.select(\".user_line\")\n      \n      state.drawn_line_color = draw_color;\n      \n      user_line.style(\"stroke\", draw_color)\n      \n      conf_int_line_attrs.stroke = draw_color;\n    }\n  })\n};\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  let newLineColor = null;\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n        buttonText.text(\"New Line\");\n          buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n        svg.select(\".color-palette\").style(\"display\", \"none\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n          // Define the colors for the palette.\n    var colors = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\"];\n    \n    // Define the width and height of each color block.\n    var blockWidth = 30, blockHeight = 30;\n    \n    // Define the positions for each color block.\n    var positions = [\n        {x: 0, y: 0}, {x: blockWidth, y: 0}, {x: 2 * blockWidth, y: 0},  // First row\n        {x: 0, y: blockHeight}, {x: blockWidth, y: blockHeight}, {x: 2 * blockWidth, y: blockHeight}  // Second row\n    ];\n\n    // Create the color palette if it doesn't exist.\n    var colorPalette = svg.select(\".color-palette\");\n    if (colorPalette.empty()) {\n        colorPalette = svg.append(\"g\")\n            .attr(\"class\", \"color-palette\")\n            .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 135})`)  // Position it below the New Line button.\n            .style(\"display\", \"block\");  // Hide it initially.\n            \n        // Create an outer border for the color palette.\n        colorPalette.append(\"rect\")\n          .attr(\"x\", -5)  // Slightly larger than the color blocks and title.\n          .attr(\"y\", -20)  // Enough to include the title.\n          .attr(\"width\", blockWidth * 3 + 10)  // Again, slightly larger.\n          .attr(\"height\", blockHeight * 2 + 25)  // Enough to include the title.\n          .attr(\"rx\", 5)  // Rounded corners.\n          .attr(\"ry\", 5)  // Rounded corners.\n          .style(\"fill\", \"#ECECEC\")  // Same color as the background.\n          .style(\"stroke\", \"black\")  // Black border.\n          .style(\"stroke-width\", 2);  // Border thickness.\n        \n        // Create a title for the color palette.\n        colorPalette.append(\"text\")\n          .attr(\"x\", blockWidth * 3 / 2)\n          .attr(\"y\", -5)  // Position the title above the color blocks.\n          .attr(\"text-anchor\", \"middle\")  // Center the text.\n          .style(\"font-size\", \"14px\")\n          .text(\"Line Color\");\n          \n        colorPalette.append(\"rect\")\n          .attr(\"width\", blockWidth * 3)\n          .attr(\"height\", blockHeight * 2)\n          .style(\"fill\", \"none\")\n          .style(\"stroke\", \"black\")\n          .style(\"stroke-width\", 2);\n          \n        // Create color blocks.\n        colors.forEach(function(color, i) {\n          colorPalette.append(\"rect\")\n              .attr(\"x\", positions[i].x)\n              .attr(\"y\", positions[i].y)\n              .attr(\"width\", blockWidth)\n              .attr(\"height\", blockHeight)\n              .attr(\"fill\", color)\n              .style(\"stroke\", \"black\")\n              .style(\"stroke-width\", 1)\n              .on(\"click\", function() {\n                path.attr(\"stroke\", color);\n              // Hide the palette when a color is selected.\n              colorPalette.style(\"display\", \"none\");\n            })\n            .on(\"mouseover\", function() {\n               // Create a darker color on mouseover\n              let darkerColor = d3.rgb(d3.color(color)).darker(0.7);\n              d3.select(this).style(\"fill\", darkerColor);\n            })\n            .on(\"mouseout\", function() {\n              // Return to original color on mouseout\n              d3.select(this).style(\"fill\", color);\n            });\n        });\n      }\n      else {\n        colorPalette.style(\"display\", \"block\")\n      }\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n    \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n    const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      if (!state.hide_buttons) {\n        svg.select(\".color-palette\").remove();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n  if(state.title){\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 - 10,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2,\n        dominantBaseline: 'middle',\n        fontSize: '21px',\n      })\n      .style('font-family', system_font)\n      .text(state.title);\n    }\n  }\n  \n  // Do we have a subtitle?\n  if (state.subtitle){\n    state.svg.append('text')\n    .at({\n      y: -margin.top/2 + 10,\n      dominantBaseline: 'middle',\n      fontSize: '13px',\n    })\n    .style('font-family', system_font)\n    .text(state.subtitle);\n  }\n  \n  // Do we have an x-axis label?\n  if (state.x_lab) {\n    if (state.subtitle) {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '13px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n    else {\n      state.svg.append('text')\n      .at({\n        x: state.w / 2,\n        y: state.h + margin.bottom - 4,\n        fontSize: '16px',\n        textAnchor: 'middle',\n      })\n      .style('font-family', system_font)\n      .text(state.x_lab);\n    }\n  }\n  \n  // Do we have a y-axis label?\n  if (state.y_lab) {\n    if (state.subtitle) {\n      state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"13px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n  }\n    else {\n    state.svg.append(\"text\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"x\", 0 - (state.h / 2))\n      .attr(\"y\",  -margin.right - 22)\n      .attr(\"font-size\", \"16px\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-family\", system_font)\n      .text(state.y_lab);\n    }\n  }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      const threshold = 0.0005 * x_range;\n      \n    if (free_draw) {\n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .filter((d, i, arr) => i === 0 || Math.abs(d.x - arr[i - 1].x) > threshold)\n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltipGroup = svg.append(\"g\")\n      .attr(\"class\", \"tooltipGroup\")\n      .attr(\"visibility\", \"hidden\");\n  \n  // Define a drop shadow filter\n  var defs = svg.append(\"defs\");\n  var filter = defs.append(\"filter\")\n      .attr(\"id\", \"drop-shadow\")\n      .attr(\"height\", \"130%\");\n  filter.append(\"feGaussianBlur\")\n      .attr(\"in\", \"SourceAlpha\")\n      .attr(\"stdDeviation\", 2)\n      .attr(\"result\", \"blur\");\n  filter.append(\"feOffset\")\n      .attr(\"in\", \"blur\")\n      .attr(\"dx\", 1)\n      .attr(\"dy\", 1)\n      .attr(\"result\", \"offsetBlur\");\n  var feMerge = filter.append(\"feMerge\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"offsetBlur\");\n  feMerge.append(\"feMergeNode\")\n      .attr(\"in\", \"SourceGraphic\");\n  \n  // Append a rectangle for the tooltip background\n  tooltipGroup.append(\"rect\")\n      .attr(\"width\", 105)  // Adjusted width\n      .attr(\"height\", 25)  // Adjusted height\n      .attr(\"rx\", 8)  // Rounded corners\n      .attr(\"ry\", 8)  // Rounded corners\n      .attr(\"fill\", \"#fff\")\n      .attr(\"stroke\", \"#ccc\")\n      .style(\"filter\", \"url(#drop-shadow)\");  // Apply the drop shadow filter\n  \n  // Append a text element for the tooltip text\n  tooltipGroup.append(\"text\")\n      .attr(\"x\", 7)  // Adjusted position\n      .attr(\"y\", 17)  // Adjusted position\n      .attr(\"font-size\", \"12px\")  // Reduced font size\n      .text(\"\");\n}\n\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  tooltipGroup.style(\"opacity\", 0);\n    Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n        showTooltip = newState;\n        if (newState) {\n            // Show the tooltip group\n            tooltipGroup.style(\"opacity\", 1);\n        } else {\n            // Hide the tooltip group\n            tooltipGroup.style(\"opacity\", 0);\n        }\n    });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    let draw_region_color = state.draw_region_color !== null && state.draw_region_color !== undefined ? state.draw_region_color : \"rgba(0,0,0,0)\";\n    \n  draw_region\n    .attr(\"x\", drawSpace_start)\n    .attr(\"width\",drawSpace_end - drawSpace_start)\n    .attr(\"y\", 0)\n    .attr(\"height\", state.h)\n    .style(\"fill\", draw_region_color)\n    .style(\"fill-opacity\", draw_region_color === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n    \n    if (typeof Shiny !== 'undefined') {\n      Shiny.addCustomMessageHandler('regionColorAction', function(regionColor) {\n        draw_region\n          .style(\"fill\", regionColor)\n          .style(\"fill-opacity\", regionColor === \"rgba(0,0,0,0)\" ? 0 : 0.4);\n          \n        state.draw_region_color = regionColor;\n      })\n    };\n\n    if (typeof tooltipGroup  !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Update tooltip text\n        tooltipGroup.select(\"text\").text(\"Progress: \" + (progress * 100).toFixed(2) + \"%\");\n\n        // Show tooltip and set its position\n        tooltipGroup.attr(\"transform\", `translate(${mouseX + 50},${mouseY - 20})`)\n            .attr(\"visibility\", \"visible\");\n      } else {\n        // Hide tooltip\n        tooltipGroup.attr(\"visibility\", \"hidden\");\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltipGroup.attr(\"visibility\", \"hidden\");\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  const shaded_area = state.svg.selectAppend(\"path.shaded_area\");\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    shaded_area.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    // Defining the area of shaded region\n    var area = d3.area()\n        .x(function(d, i) { return scales.x(d.x); })\n        .y0(function(d, i) { return scales.y(upr[i].y); })\n        .y1(function(d, i) { return scales.y(lwr[i].y); });\n        \n    let data_line_color = state.data_line_color !== null && options.data_line_color !== undefined ? options.data_line_color : 'steelblue';\n    let colorRGB = d3.rgb(data_line_color);\n    \n    // Convert to HSL and increase saturation\n    let colorHSL = d3.hsl(colorRGB);\n    colorHSL.s = Math.min(1, colorHSL.s + 0.3); // Increase saturation by 20% but not more than 1\n    \n    // Convert back to RGB\n    let moreSaturatedColorRGB = d3.rgb(colorHSL);\n    let lighterColor = `rgba(${moreSaturatedColorRGB.r},${moreSaturatedColorRGB.g},${moreSaturatedColorRGB.b},0.2)`;  // 20% opacity\n\n    shaded_area\n      .datum(df)\n      .attr(\"d\", area)\n      .style('fill', lighterColor);\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script></details><div class="section level3">
<h3 id="examples-of-using-the-new-line-button">Examples of Using the New Line Button<a class="anchor" aria-label="anchor" href="#examples-of-using-the-new-line-button"></a>
</h3>
<p>The New Line button in <code><a href="../reference/drawr.html">drawr()</a></code> opens up a range of
possibilities for interactive data analysis and visualization. Here are
a few examples of how you can leverage this feature:</p>
<p><strong>Confidence/Prediction Intervals:</strong> By drawing
additional lines above and below the original regression line, you can
create a visual representation of confidence or prediction intervals.
This can give a sense of the variability in your data and the precision
of your predictions. Additionally, you can check your own drawn
confidence intervals with generated confidence intervals from the
<code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> or <code><a href="../reference/customDataGen.html">customDataGen()</a></code>
functions.</p>
<p><strong>Model Deviation:</strong> Sketch lines or shapes to indicate
where your data diverges from the model predictions. This can help in
visualizing the residuals or variance around your regression line. It
can also help visualize if your modelâ€™s errors are normally distributed
(drawing a bell shape) or if they have some sort of skewness or patterns
that might need further investigation.</p>
<p><strong>Outlier Identification:</strong> Use the New Line button to
draw shapes around potential outliers. This makes them easy to identify
and discuss.</p>
<p><strong>Areas of Interest:</strong> Highlight specific regions on the
graph that you want to focus on or further investigate.</p>
<p><strong>Analyzing Potential Outcomes:</strong> Use the New Line
button to visualize the implications of changes to your data. For
instance, if you have certain expectations about how your data might
evolve in the future, you could draw these as new lines on your graph.
This could include potential increases or decreases in trends, the
emergence of new patterns, or changes to the variability of your data.
By visualizing these different potential outcomes, you can more
effectively prepare for these possibilities and understand how they
might impact your modelâ€™s predictions.</p>
<p>Remember, these are just a few examples and there might be many other
creative ways to use the New Line button, depending on your specific use
case and data analysis/educative needs.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Emily A. Robinson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
