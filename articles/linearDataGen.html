<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="youdrawitR">
<title>Examples: linearDataGen • youdrawitR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Examples: linearDataGen">
<meta property="og:description" content="youdrawitR">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">youdrawitR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <h6 class="dropdown-header" data-toc-skip>Examples</h6>
    <a class="dropdown-item" href="../articles/customDataGen.html">customDataGen</a>
    <a class="dropdown-item" href="../articles/linearDataGen.html">linearDataGen</a>
    <div class="dropdown-divider"></div>
    <h6 class="dropdown-header" data-toc-skip>Extra</h6>
    <a class="dropdown-item" href="../articles/web_only/ShinyApp.html">Shiny App</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/earobinson95/youdrawitR/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">



<script src="linearDataGen_files/htmlwidgets-1.6.2/htmlwidgets.js"></script><script src="linearDataGen_files/r2d3-render-0.1.0/r2d3-render.js"></script><script src="linearDataGen_files/webcomponents-2.0.0/webcomponents.js"></script><script src="linearDataGen_files/r2d3-binding-0.2.6/r2d3.js"></script><script src="linearDataGen_files/d3v5-5.9.2/d3.min.js"></script><script src="linearDataGen_files/d3-jetpack-2.0.9/d3-jetpack.js"></script><div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Examples: linearDataGen</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/earobinson95/youdrawitR/blob/HEAD/vignettes/linearDataGen.Rmd" class="external-link"><code>vignettes/linearDataGen.Rmd</code></a></small>
      <div class="d-none name"><code>linearDataGen.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>The <code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> function in the
<code>youdrawitR</code> package allows you to generate linear line and
point data suitable for the <code><a href="../reference/drawr.html">drawr()</a></code> function. This vignette
will guide you on how to use this function and visualize the generated
data.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://earobinson95.github.io/youdrawitR/">youdrawitR</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="generating-linear-data">Generating Linear Data<a class="anchor" aria-label="anchor" href="#generating-linear-data"></a>
</h2>
<p>Let’s generate some simple linear data.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span> <span class="co"># Set seed to generate consistent data</span></span>
<span></span>
<span><span class="co"># Generate linear data</span></span>
<span><span class="va">linear_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/linearDataGen.html">linearDataGen</a></span><span class="op">(</span></span>
<span>  y_int <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  slope <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  sigma <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  N <span class="op">=</span> <span class="fl">30</span>,</span>
<span>  x_min <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  x_max <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  conf_int <span class="op">=</span> <span class="cn">F</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> function takes several
arguments:</p>
<ul>
<li><p>y_int and slope define the y-intercept and slope of the line
data.</p></li>
<li><p>sigma is the standard deviation of the point data.</p></li>
<li><p>N is the number of points to generate. Default is 30.</p></li>
<li><p>x_min and x_max are the minimum and maximum x values for the line
and point data. Defaults are 0 and 20.</p></li>
<li><p>conf_int is a logical argument specifying whether a 95%
confidence interval should be generated for the drawr function. Default
is FALSE. If TRUE, user must also specify conf_int = TRUE in the
<code><a href="../reference/drawr.html">drawr()</a></code> function to generate 95% confidence interval upper
and lower boundary lines.</p></li>
</ul>
<p>The <code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> function returns a list containing
the point data and line data generated from the parameters. Let’s take a
look at the data that was generated from the example above:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">linear_data</span></span>
<span><span class="co">#&gt; $point_data</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 30 × 3</span></span></span>
<span><span class="co">#&gt;    data           x      y</span></span>
<span><span class="co">#&gt;    <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>      <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 1</span> point_data 0     -<span style="color: #BB0000;">1.12</span> </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 2</span> point_data 0.690  0.919</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 3</span> point_data 1.38   5.88 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 4</span> point_data 2.07   4.28 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 5</span> point_data 2.76   5.78 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 6</span> point_data 3.45  10.3  </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 7</span> point_data 4.14   9.20 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 8</span> point_data 4.83   7.13 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 9</span> point_data 5.52   9.66 </span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">10</span> point_data 6.21  11.5  </span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># ℹ 20 more rows</span></span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $line_data</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 81 × 5</span></span></span>
<span><span class="co">#&gt;    data          x     y  coef   int</span></span>
<span><span class="co">#&gt;    <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 1</span> line_data  0    0.619  1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 2</span> line_data  0.25 1.10   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 3</span> line_data  0.5  1.58   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 4</span> line_data  0.75 2.07   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 5</span> line_data  1    2.55   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 6</span> line_data  1.25 3.03   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 7</span> line_data  1.5  3.51   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 8</span> line_data  1.75 3.99   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;"> 9</span> line_data  2    4.48   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">10</span> line_data  2.25 4.96   1.93 0.619</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># ℹ 71 more rows</span></span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="plotting-the-linear-data">Plotting the Linear Data<a class="anchor" aria-label="anchor" href="#plotting-the-linear-data"></a>
</h2>
<p>Once the linear data is generated, you can use the
<code><a href="../reference/drawr.html">drawr()</a></code> function from the <code>youdrawitR</code> package
to plot it, See example below:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">linear_data</span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-44474b3e8cd160f85a98" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-44474b3e8cd160f85a98">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-1.121,"_row":1},{"data":"point_data","x":0.6897,"y":0.919,"_row":2},{"data":"point_data","x":1.3793,"y":5.876,"_row":3},{"data":"point_data","x":2.069,"y":4.2789,"_row":4},{"data":"point_data","x":2.7586,"y":5.7758,"_row":5},{"data":"point_data","x":3.4483,"y":10.3267,"_row":6},{"data":"point_data","x":4.1379,"y":9.1977,"_row":7},{"data":"point_data","x":4.8276,"y":7.125,"_row":8},{"data":"point_data","x":5.5172,"y":9.6608,"_row":9},{"data":"point_data","x":6.2069,"y":11.5225,"_row":10},{"data":"point_data","x":6.8966,"y":16.2413,"_row":11},{"data":"point_data","x":7.5862,"y":15.892,"_row":12},{"data":"point_data","x":8.2759,"y":17.3533,"_row":13},{"data":"point_data","x":8.9655,"y":18.1524,"_row":14},{"data":"point_data","x":9.6552,"y":18.1987,"_row":15},{"data":"point_data","x":10.3448,"y":24.2635,"_row":16},{"data":"point_data","x":11.0345,"y":23.0647,"_row":17},{"data":"point_data","x":11.7241,"y":19.515,"_row":18},{"data":"point_data","x":12.4138,"y":26.2303,"_row":19},{"data":"point_data","x":13.1034,"y":25.2613,"_row":20},{"data":"point_data","x":13.7931,"y":25.4506,"_row":21},{"data":"point_data","x":14.4828,"y":28.5296,"_row":22},{"data":"point_data","x":15.1724,"y":28.2928,"_row":23},{"data":"point_data","x":15.8621,"y":30.2664,"_row":24},{"data":"point_data","x":16.5517,"y":31.8534,"_row":25},{"data":"point_data","x":17.2414,"y":31.1094,"_row":26},{"data":"point_data","x":17.931,"y":37.5376,"_row":27},{"data":"point_data","x":18.6207,"y":37.5481,"_row":28},{"data":"point_data","x":19.3103,"y":36.3444,"_row":29},{"data":"point_data","x":20,"y":42.5076,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":0.6193,"coef":1.9287,"int":0.6193,"_row":1},{"data":"line_data","x":0.25,"y":1.1014,"coef":1.9287,"int":0.6193,"_row":2},{"data":"line_data","x":0.5,"y":1.5836,"coef":1.9287,"int":0.6193,"_row":3},{"data":"line_data","x":0.75,"y":2.0657,"coef":1.9287,"int":0.6193,"_row":4},{"data":"line_data","x":1,"y":2.5479,"coef":1.9287,"int":0.6193,"_row":5},{"data":"line_data","x":1.25,"y":3.0301,"coef":1.9287,"int":0.6193,"_row":6},{"data":"line_data","x":1.5,"y":3.5122,"coef":1.9287,"int":0.6193,"_row":7},{"data":"line_data","x":1.75,"y":3.9944,"coef":1.9287,"int":0.6193,"_row":8},{"data":"line_data","x":2,"y":4.4766,"coef":1.9287,"int":0.6193,"_row":9},{"data":"line_data","x":2.25,"y":4.9587,"coef":1.9287,"int":0.6193,"_row":10},{"data":"line_data","x":2.5,"y":5.4409,"coef":1.9287,"int":0.6193,"_row":11},{"data":"line_data","x":2.75,"y":5.9231,"coef":1.9287,"int":0.6193,"_row":12},{"data":"line_data","x":3,"y":6.4052,"coef":1.9287,"int":0.6193,"_row":13},{"data":"line_data","x":3.25,"y":6.8874,"coef":1.9287,"int":0.6193,"_row":14},{"data":"line_data","x":3.5,"y":7.3695,"coef":1.9287,"int":0.6193,"_row":15},{"data":"line_data","x":3.75,"y":7.8517,"coef":1.9287,"int":0.6193,"_row":16},{"data":"line_data","x":4,"y":8.3339,"coef":1.9287,"int":0.6193,"_row":17},{"data":"line_data","x":4.25,"y":8.816,"coef":1.9287,"int":0.6193,"_row":18},{"data":"line_data","x":4.5,"y":9.2982,"coef":1.9287,"int":0.6193,"_row":19},{"data":"line_data","x":4.75,"y":9.7804,"coef":1.9287,"int":0.6193,"_row":20},{"data":"line_data","x":5,"y":10.2625,"coef":1.9287,"int":0.6193,"_row":21},{"data":"line_data","x":5.25,"y":10.7447,"coef":1.9287,"int":0.6193,"_row":22},{"data":"line_data","x":5.5,"y":11.2269,"coef":1.9287,"int":0.6193,"_row":23},{"data":"line_data","x":5.75,"y":11.709,"coef":1.9287,"int":0.6193,"_row":24},{"data":"line_data","x":6,"y":12.1912,"coef":1.9287,"int":0.6193,"_row":25},{"data":"line_data","x":6.25,"y":12.6733,"coef":1.9287,"int":0.6193,"_row":26},{"data":"line_data","x":6.5,"y":13.1555,"coef":1.9287,"int":0.6193,"_row":27},{"data":"line_data","x":6.75,"y":13.6377,"coef":1.9287,"int":0.6193,"_row":28},{"data":"line_data","x":7,"y":14.1198,"coef":1.9287,"int":0.6193,"_row":29},{"data":"line_data","x":7.25,"y":14.602,"coef":1.9287,"int":0.6193,"_row":30},{"data":"line_data","x":7.5,"y":15.0842,"coef":1.9287,"int":0.6193,"_row":31},{"data":"line_data","x":7.75,"y":15.5663,"coef":1.9287,"int":0.6193,"_row":32},{"data":"line_data","x":8,"y":16.0485,"coef":1.9287,"int":0.6193,"_row":33},{"data":"line_data","x":8.25,"y":16.5306,"coef":1.9287,"int":0.6193,"_row":34},{"data":"line_data","x":8.5,"y":17.0128,"coef":1.9287,"int":0.6193,"_row":35},{"data":"line_data","x":8.75,"y":17.495,"coef":1.9287,"int":0.6193,"_row":36},{"data":"line_data","x":9,"y":17.9771,"coef":1.9287,"int":0.6193,"_row":37},{"data":"line_data","x":9.25,"y":18.4593,"coef":1.9287,"int":0.6193,"_row":38},{"data":"line_data","x":9.5,"y":18.9415,"coef":1.9287,"int":0.6193,"_row":39},{"data":"line_data","x":9.75,"y":19.4236,"coef":1.9287,"int":0.6193,"_row":40},{"data":"line_data","x":10,"y":19.9058,"coef":1.9287,"int":0.6193,"_row":41},{"data":"line_data","x":10.25,"y":20.388,"coef":1.9287,"int":0.6193,"_row":42},{"data":"line_data","x":10.5,"y":20.8701,"coef":1.9287,"int":0.6193,"_row":43},{"data":"line_data","x":10.75,"y":21.3523,"coef":1.9287,"int":0.6193,"_row":44},{"data":"line_data","x":11,"y":21.8344,"coef":1.9287,"int":0.6193,"_row":45},{"data":"line_data","x":11.25,"y":22.3166,"coef":1.9287,"int":0.6193,"_row":46},{"data":"line_data","x":11.5,"y":22.7988,"coef":1.9287,"int":0.6193,"_row":47},{"data":"line_data","x":11.75,"y":23.2809,"coef":1.9287,"int":0.6193,"_row":48},{"data":"line_data","x":12,"y":23.7631,"coef":1.9287,"int":0.6193,"_row":49},{"data":"line_data","x":12.25,"y":24.2453,"coef":1.9287,"int":0.6193,"_row":50},{"data":"line_data","x":12.5,"y":24.7274,"coef":1.9287,"int":0.6193,"_row":51},{"data":"line_data","x":12.75,"y":25.2096,"coef":1.9287,"int":0.6193,"_row":52},{"data":"line_data","x":13,"y":25.6918,"coef":1.9287,"int":0.6193,"_row":53},{"data":"line_data","x":13.25,"y":26.1739,"coef":1.9287,"int":0.6193,"_row":54},{"data":"line_data","x":13.5,"y":26.6561,"coef":1.9287,"int":0.6193,"_row":55},{"data":"line_data","x":13.75,"y":27.1382,"coef":1.9287,"int":0.6193,"_row":56},{"data":"line_data","x":14,"y":27.6204,"coef":1.9287,"int":0.6193,"_row":57},{"data":"line_data","x":14.25,"y":28.1026,"coef":1.9287,"int":0.6193,"_row":58},{"data":"line_data","x":14.5,"y":28.5847,"coef":1.9287,"int":0.6193,"_row":59},{"data":"line_data","x":14.75,"y":29.0669,"coef":1.9287,"int":0.6193,"_row":60},{"data":"line_data","x":15,"y":29.5491,"coef":1.9287,"int":0.6193,"_row":61},{"data":"line_data","x":15.25,"y":30.0312,"coef":1.9287,"int":0.6193,"_row":62},{"data":"line_data","x":15.5,"y":30.5134,"coef":1.9287,"int":0.6193,"_row":63},{"data":"line_data","x":15.75,"y":30.9956,"coef":1.9287,"int":0.6193,"_row":64},{"data":"line_data","x":16,"y":31.4777,"coef":1.9287,"int":0.6193,"_row":65},{"data":"line_data","x":16.25,"y":31.9599,"coef":1.9287,"int":0.6193,"_row":66},{"data":"line_data","x":16.5,"y":32.442,"coef":1.9287,"int":0.6193,"_row":67},{"data":"line_data","x":16.75,"y":32.9242,"coef":1.9287,"int":0.6193,"_row":68},{"data":"line_data","x":17,"y":33.4064,"coef":1.9287,"int":0.6193,"_row":69},{"data":"line_data","x":17.25,"y":33.8885,"coef":1.9287,"int":0.6193,"_row":70},{"data":"line_data","x":17.5,"y":34.3707,"coef":1.9287,"int":0.6193,"_row":71},{"data":"line_data","x":17.75,"y":34.8529,"coef":1.9287,"int":0.6193,"_row":72},{"data":"line_data","x":18,"y":35.335,"coef":1.9287,"int":0.6193,"_row":73},{"data":"line_data","x":18.25,"y":35.8172,"coef":1.9287,"int":0.6193,"_row":74},{"data":"line_data","x":18.5,"y":36.2993,"coef":1.9287,"int":0.6193,"_row":75},{"data":"line_data","x":18.75,"y":36.7815,"coef":1.9287,"int":0.6193,"_row":76},{"data":"line_data","x":19,"y":37.2637,"coef":1.9287,"int":0.6193,"_row":77},{"data":"line_data","x":19.25,"y":37.7458,"coef":1.9287,"int":0.6193,"_row":78},{"data":"line_data","x":19.5,"y":38.228,"coef":1.9287,"int":0.6193,"_row":79},{"data":"line_data","x":19.75,"y":38.7102,"coef":1.9287,"int":0.6193,"_row":80},{"data":"line_data","x":20,"y":39.1923,"coef":1.9287,"int":0.6193,"_row":81}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-3.302380349866639,44.68905889890207],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","show_finished":true,"show_tooltip":false,"title":"","conf_int":false},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 30 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 2,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n      buttonText.text(\"New Line\");\n        buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n  \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n        const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n    if(state.title){\n      if (state.subtitle) {\n        state.svg.append('text')\n        .at({\n          y: -margin.top/2 - 10,\n          dominantBaseline: 'middle',\n          fontSize: '1.3rem',\n        })\n        .style('font-family', system_font)\n        .text(state.title);\n      }\n      else {\n        state.svg.append('text')\n        .at({\n          y: -margin.top/2,\n          dominantBaseline: 'middle',\n          fontSize: '1.5rem',\n        })\n        .style('font-family', system_font)\n        .text(state.title);\n      }\n    }\n    \n    // Do we have a subtitle?\n    if (state.subtitle){\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 + 10,\n        dominantBaseline: 'middle',\n        fontSize: '0.8rem',\n      })\n      .style('font-family', system_font)\n      .text(state.subtitle);\n    }\n    \n    // Do we have an x-axis label?\n    if (state.x_lab) {\n      if (state.subtitle) {\n        state.svg.append('text')\n        .at({\n          x: state.w / 2,\n          y: state.h + margin.bottom,\n          fontSize: '0.8rem',\n          textAnchor: 'middle',\n        })\n        .style('font-family', system_font)\n        .text(state.x_lab);\n      }\n      else {\n        state.svg.append('text')\n        .at({\n          x: state.w / 2,\n          y: state.h + margin.bottom,\n          fontSize: '1rem',\n          textAnchor: 'middle',\n        })\n        .style('font-family', system_font)\n        .text(state.x_lab);\n      }\n    }\n    \n    // Do we have a y-axis label?\n    if (state.y_lab) {\n      if (state.subtitle) {\n        state.svg.append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"x\", 0 - (state.h / 2))\n        .attr(\"y\",  -margin.right - 22)\n        .attr(\"font-size\", \"0.8rem\")\n        .attr(\"text-anchor\", \"middle\")\n        .style(\"font-family\", system_font)\n        .text(state.y_lab);\n    }\n      else {\n      state.svg.append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"x\", 0 - (state.h / 2))\n        .attr(\"y\",  -margin.right - 22)\n        .attr(\"font-size\", \"1rem\")\n        .attr(\"text-anchor\", \"middle\")\n        .style(\"font-family\", system_font)\n        .text(state.y_lab);\n      }\n    }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n    if (free_draw) {\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || d.x !== arr[i - 1].x)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    draw_region\n      .attr(\"x\", drawSpace_start)\n      .attr(\"width\",drawSpace_end - drawSpace_start)\n      .attr(\"y\", 0)\n      .attr(\"height\", state.h)\n      //.style(\"fill\", \"#e0f3f3\")\n      .style(\"fill-opacity\", 0.4)\n      .style(\"fill\", \"rgba(255,255,0,.8)\")\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    lower_bound\n    .datum(lwr)\n    .at(conf_int_line_attrs)\n    .attr(\"d\", scales.line_drawer)\n    .attr(\"opacity\", 0.5)\n    \n    upper_bound\n    .datum(upr)\n    .at(conf_int_line_attrs)\n    .attr(\"d\", scales.line_drawer)\n    .attr(\"opacity\", 0.5)\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>In the plot above, you can try to draw the trend line. You’ll notice
that the data has a clear linear relationship between x and y, which can
be readily visualized with this function.</p>
<p>You can experiment with different settings of the
<code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> function’s parameters to generate different
types of linear data.</p>
</div>
<div class="section level2">
<h2 id="confidence-intervals">Confidence Intervals<a class="anchor" aria-label="anchor" href="#confidence-intervals"></a>
</h2>
<p>One important feature in the <code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> function,
and <code>youdrawitR</code> package in general is the ability to add
lines on the interactive graphic. One useful instance of this is for the
user to generate and draw 95% confidence intervals for the line of best
fit. When set to conf_int = TRUE in the <code><a href="../reference/linearDataGen.html">linearDataGen()</a></code> and
<code><a href="../reference/drawr.html">drawr()</a></code> functions, the functions will generate lower and
upper bounds for the confidence interval.</p>
<p>Let’s generate some linear data with a confidence interval.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span> <span class="co"># Set seed to generate consistent data</span></span>
<span></span>
<span><span class="co"># Generate linear data</span></span>
<span><span class="va">linear_data_conf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/linearDataGen.html">linearDataGen</a></span><span class="op">(</span></span>
<span>  y_int <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  slope <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  sigma <span class="op">=</span> <span class="fl">8</span>,</span>
<span>  N <span class="op">=</span> <span class="fl">30</span>,</span>
<span>  x_min <span class="op">=</span> <span class="fl">0</span>,</span>
<span>  x_max <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  conf_int <span class="op">=</span> <span class="cn">T</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the data with a confidence interval</span></span>
<span><span class="fu"><a href="../reference/drawr.html">drawr</a></span><span class="op">(</span></span>
<span>  <span class="va">linear_data_conf</span>,</span>
<span>  conf_int <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  title <span class="op">=</span> <span class="st">"Visualization with Confidence Interval"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="r2d3 html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-2514ce28ae593bde0f73" style="width:700px;height:432.632880098888px;"></div>
<script type="application/json" data-for="htmlwidget-2514ce28ae593bde0f73">{"x":{"data":{"point_data":[{"data":"point_data","x":0,"y":-4.4838,"_row":1},{"data":"point_data","x":0.6897,"y":-0.4621,"_row":2},{"data":"point_data","x":1.3793,"y":15.2283,"_row":3},{"data":"point_data","x":2.069,"y":4.702,"_row":4},{"data":"point_data","x":2.7586,"y":6.5515,"_row":5},{"data":"point_data","x":3.4483,"y":20.6171,"_row":6},{"data":"point_data","x":4.1379,"y":11.9632,"_row":7},{"data":"point_data","x":4.8276,"y":-0.4653,"_row":8},{"data":"point_data","x":5.5172,"y":5.5397,"_row":9},{"data":"point_data","x":6.2069,"y":8.8485,"_row":10},{"data":"point_data","x":6.8966,"y":23.5858,"_row":11},{"data":"point_data","x":7.5862,"y":18.0509,"_row":12},{"data":"point_data","x":8.2759,"y":19.7579,"_row":13},{"data":"point_data","x":8.9655,"y":18.8165,"_row":14},{"data":"point_data","x":9.6552,"y":14.8636,"_row":15},{"data":"point_data","x":10.3448,"y":34.985,"_row":16},{"data":"point_data","x":11.0345,"y":26.0518,"_row":17},{"data":"point_data","x":11.7241,"y":7.7153,"_row":18},{"data":"point_data","x":12.4138,"y":30.4384,"_row":19},{"data":"point_data","x":13.1034,"y":22.4246,"_row":20},{"data":"point_data","x":13.7931,"y":19.0436,"_row":21},{"data":"point_data","x":14.4828,"y":27.2217,"_row":22},{"data":"point_data","x":15.1724,"y":22.1368,"_row":23},{"data":"point_data","x":15.8621,"y":25.893,"_row":24},{"data":"point_data","x":16.5517,"y":28.1031,"_row":25},{"data":"point_data","x":17.2414,"y":20.9892,"_row":26},{"data":"point_data","x":17.931,"y":42.5644,"_row":27},{"data":"point_data","x":18.6207,"y":38.4684,"_row":28},{"data":"point_data","x":19.3103,"y":29.5156,"_row":29},{"data":"point_data","x":20,"y":50.0305,"_row":30}],"line_data":[{"data":"line_data","x":0,"y":2.477,"coef":1.7146,"int":2.477,"lower_bound":-3.207,"upper_bound":8.1611,"_row":1},{"data":"line_data","x":0.6897,"y":3.6595,"coef":1.7146,"int":2.477,"lower_bound":-1.7383,"upper_bound":9.0573,"_row":2},{"data":"line_data","x":1.3793,"y":4.842,"coef":1.7146,"int":2.477,"lower_bound":-0.2756,"upper_bound":9.9597,"_row":3},{"data":"line_data","x":2.069,"y":6.0245,"coef":1.7146,"int":2.477,"lower_bound":1.1798,"upper_bound":10.8692,"_row":4},{"data":"line_data","x":2.7586,"y":7.207,"coef":1.7146,"int":2.477,"lower_bound":2.6267,"upper_bound":11.7873,"_row":5},{"data":"line_data","x":3.4483,"y":8.3895,"coef":1.7146,"int":2.477,"lower_bound":4.0637,"upper_bound":12.7153,"_row":6},{"data":"line_data","x":4.1379,"y":9.572,"coef":1.7146,"int":2.477,"lower_bound":5.4887,"upper_bound":13.6553,"_row":7},{"data":"line_data","x":4.8276,"y":10.7545,"coef":1.7146,"int":2.477,"lower_bound":6.8995,"upper_bound":14.6094,"_row":8},{"data":"line_data","x":5.5172,"y":11.937,"coef":1.7146,"int":2.477,"lower_bound":8.2935,"upper_bound":15.5804,"_row":9},{"data":"line_data","x":6.2069,"y":13.1195,"coef":1.7146,"int":2.477,"lower_bound":9.6676,"upper_bound":16.5713,"_row":10},{"data":"line_data","x":6.8966,"y":14.302,"coef":1.7146,"int":2.477,"lower_bound":11.0183,"upper_bound":17.5856,"_row":11},{"data":"line_data","x":7.5862,"y":15.4844,"coef":1.7146,"int":2.477,"lower_bound":12.3419,"upper_bound":18.627,"_row":12},{"data":"line_data","x":8.2759,"y":16.6669,"coef":1.7146,"int":2.477,"lower_bound":13.6345,"upper_bound":19.6994,"_row":13},{"data":"line_data","x":8.9655,"y":17.8494,"coef":1.7146,"int":2.477,"lower_bound":14.8926,"upper_bound":20.8062,"_row":14},{"data":"line_data","x":9.6552,"y":19.0319,"coef":1.7146,"int":2.477,"lower_bound":16.1137,"upper_bound":21.9502,"_row":15},{"data":"line_data","x":10.3448,"y":20.2144,"coef":1.7146,"int":2.477,"lower_bound":17.2962,"upper_bound":23.1327,"_row":16},{"data":"line_data","x":11.0345,"y":21.3969,"coef":1.7146,"int":2.477,"lower_bound":18.4401,"upper_bound":24.3537,"_row":17},{"data":"line_data","x":11.7241,"y":22.5794,"coef":1.7146,"int":2.477,"lower_bound":19.5469,"upper_bound":25.6119,"_row":18},{"data":"line_data","x":12.4138,"y":23.7619,"coef":1.7146,"int":2.477,"lower_bound":20.6193,"upper_bound":26.9045,"_row":19},{"data":"line_data","x":13.1034,"y":24.9444,"coef":1.7146,"int":2.477,"lower_bound":21.6608,"upper_bound":28.228,"_row":20},{"data":"line_data","x":13.7931,"y":26.1269,"coef":1.7146,"int":2.477,"lower_bound":22.6751,"upper_bound":29.5787,"_row":21},{"data":"line_data","x":14.4828,"y":27.3094,"coef":1.7146,"int":2.477,"lower_bound":23.6659,"upper_bound":30.9528,"_row":22},{"data":"line_data","x":15.1724,"y":28.4919,"coef":1.7146,"int":2.477,"lower_bound":24.6369,"upper_bound":32.3468,"_row":23},{"data":"line_data","x":15.8621,"y":29.6744,"coef":1.7146,"int":2.477,"lower_bound":25.591,"upper_bound":33.7577,"_row":24},{"data":"line_data","x":16.5517,"y":30.8568,"coef":1.7146,"int":2.477,"lower_bound":26.531,"upper_bound":35.1827,"_row":25},{"data":"line_data","x":17.2414,"y":32.0393,"coef":1.7146,"int":2.477,"lower_bound":27.4591,"upper_bound":36.6196,"_row":26},{"data":"line_data","x":17.931,"y":33.2218,"coef":1.7146,"int":2.477,"lower_bound":28.3771,"upper_bound":38.0666,"_row":27},{"data":"line_data","x":18.6207,"y":34.4043,"coef":1.7146,"int":2.477,"lower_bound":29.2867,"upper_bound":39.522,"_row":28},{"data":"line_data","x":19.3103,"y":35.5868,"coef":1.7146,"int":2.477,"lower_bound":30.189,"upper_bound":40.9846,"_row":29},{"data":"line_data","x":20,"y":36.7693,"coef":1.7146,"int":2.477,"lower_bound":31.0853,"upper_bound":42.4534,"_row":30}],"lower_bound":[{"x":0,"y":-3.207,"_row":1},{"x":0.6897,"y":-1.7383,"_row":2},{"x":1.3793,"y":-0.2756,"_row":3},{"x":2.069,"y":1.1798,"_row":4},{"x":2.7586,"y":2.6267,"_row":5},{"x":3.4483,"y":4.0637,"_row":6},{"x":4.1379,"y":5.4887,"_row":7},{"x":4.8276,"y":6.8995,"_row":8},{"x":5.5172,"y":8.2935,"_row":9},{"x":6.2069,"y":9.6676,"_row":10},{"x":6.8966,"y":11.0183,"_row":11},{"x":7.5862,"y":12.3419,"_row":12},{"x":8.2759,"y":13.6345,"_row":13},{"x":8.9655,"y":14.8926,"_row":14},{"x":9.6552,"y":16.1137,"_row":15},{"x":10.3448,"y":17.2962,"_row":16},{"x":11.0345,"y":18.4401,"_row":17},{"x":11.7241,"y":19.5469,"_row":18},{"x":12.4138,"y":20.6193,"_row":19},{"x":13.1034,"y":21.6608,"_row":20},{"x":13.7931,"y":22.6751,"_row":21},{"x":14.4828,"y":23.6659,"_row":22},{"x":15.1724,"y":24.6369,"_row":23},{"x":15.8621,"y":25.591,"_row":24},{"x":16.5517,"y":26.531,"_row":25},{"x":17.2414,"y":27.4591,"_row":26},{"x":17.931,"y":28.3771,"_row":27},{"x":18.6207,"y":29.2867,"_row":28},{"x":19.3103,"y":30.189,"_row":29},{"x":20,"y":31.0853,"_row":30}],"upper_bound":[{"x":0,"y":8.1611,"_row":1},{"x":0.6897,"y":9.0573,"_row":2},{"x":1.3793,"y":9.9597,"_row":3},{"x":2.069,"y":10.8692,"_row":4},{"x":2.7586,"y":11.7873,"_row":5},{"x":3.4483,"y":12.7153,"_row":6},{"x":4.1379,"y":13.6553,"_row":7},{"x":4.8276,"y":14.6094,"_row":8},{"x":5.5172,"y":15.5804,"_row":9},{"x":6.2069,"y":16.5713,"_row":10},{"x":6.8966,"y":17.5856,"_row":11},{"x":7.5862,"y":18.627,"_row":12},{"x":8.2759,"y":19.6994,"_row":13},{"x":8.9655,"y":20.8062,"_row":14},{"x":9.6552,"y":21.9502,"_row":15},{"x":10.3448,"y":23.1327,"_row":16},{"x":11.0345,"y":24.3537,"_row":17},{"x":11.7241,"y":25.6119,"_row":18},{"x":12.4138,"y":26.9045,"_row":19},{"x":13.1034,"y":28.228,"_row":20},{"x":13.7931,"y":29.5787,"_row":21},{"x":14.4828,"y":30.9528,"_row":22},{"x":15.1724,"y":32.3468,"_row":23},{"x":15.8621,"y":33.7577,"_row":24},{"x":16.5517,"y":35.1827,"_row":25},{"x":17.2414,"y":36.6196,"_row":26},{"x":17.931,"y":38.0666,"_row":27},{"x":18.6207,"y":39.522,"_row":28},{"x":19.3103,"y":40.9846,"_row":29},{"x":20,"y":42.4534,"_row":30}]},"type":"json","container":"svg","options":{"draw_start":2.225073858507201e-308,"hide_buttons":false,"points_end":null,"linear":"true","log_base":null,"free_draw":true,"points":"full","aspect_ratio":1,"pin_start":true,"x_range":[0,20],"x_by":0,"x_lab":"","y_range":[-7.209521399466556,52.75623559560827],"y_lab":"","subtitle":"","line_style":null,"drawn_line_color":"steelblue","show_finished":true,"show_tooltip":false,"title":"Visualization with Confidence Interval","conf_int":true},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  /home/runner/.cache/R/renv/library/youdrawitR-b8afb6e4/R-4.3/x86_64-pc-linux-gnu/youdrawitR/www/you-draw-it.js */\n// !preview r2d3 data = data, options = options, dependencies = c('d3-jetpack'), d3_version = \"5\", viewer = \"browser\"\n\n// Make sure R has the following loaded\n// library(tibble)\n// data_to_json <- function(data) {jsonlite::toJSON(data, dataframe = \"rows\", auto_unbox = FALSE, rownames = TRUE)} \n\n\n// define variable system_font\n const system_font = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif, \"Apple Color // // Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"`;\n\n\n// ---------------------------------------------------------------------------------------------\n\n\n// define variable margins\n// if x_lab and title true top = 30, if only title, top = 40, if only x top = 15, if neither top = 10.\nconst margin = {left: 55, \n                right: 10, \n               // top: options.title ? 40: 10, \n              //  bottom: options.title? 25: 55};\n                top: (options.subtitle) ? 40 : (options.title && options.x_lab) ? 30 : (options.title ? 40 : (options.x_lab ? 15 : 10)),\n                bottom: (options.subtitle) ? 30 : (options.title && options.x_lab) ? 35 : (options.title ? 25 : (options.x_lab ? 35 : 55))};\n\n// define variable default line attributes\n// do not fill the line in (default is filled in black beneath the line)\n// stroke provides the color of the line stroke. This is either options.data_line_color (not yet defined) or steelblue\n// sets the the stroke width (how thick)\n// sets how tojoin the lines? and end the lines? rounded.\n// Since we are using Object.assign, we are passing the source options.line_style into the vector of information defined. See top for options list.\nconst default_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 4,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n}, options.line_style);\n\nconst conf_int_line_attrs = Object.assign({\n  fill: \"none\",\n  stroke: options.data_line_color || 'steelblue',\n  strokeWidth: 2,\n  strokeLinejoin: \"round\",\n  strokeLinecap: \"round\",\n  strokeDasharray: \"10, 20\"\n}, options.line_style);\n\n// defines a changing variable called state??\n// provides the data from top\n// appends the svg group and moves it to the correct location...\n// sets the width and height of the plot\n// Since we are using object.assign, the options are passed in as the source, this will \"overwrite\" any information provided in the options???\n// Is state like our wrapper?\n\nlet state = Object.assign({\n  line_data: data.line_data,\n  point_data: data.point_data,\n  lower_bound: data.lower_bound,\n  upper_bound: data.upper_bound,\n  svg: svg.append('g').translate([margin.left, margin.top]).attr(\"class\", \"wrapper\"),\n  w: height*options.aspect_ratio - margin.left - margin.right,\n  h: height - margin.top - margin.bottom,\n}, options);\n\n// option variables are passed into state\n// console.log(state.y_range)\n\n// To distinguish between code that runs at initialization-time only and\n// code that runs when data changes, organize your code so that the code\n// which responds to data changes is contained within the r2d3.onRender()\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\nr2d3.onRender(function(data, svg, width, height, options) {\n  \n  state.line_data = data.line_data;\n  state.point_data = data.point_data;\n  state = Object.assign(state, options);\n  if (state.conf_int) {\n    state.lower_bound = data.lower_bound;\n    state.upper_bound = data.upper_bound;\n  }\n  state.options = options;\n  state.w = height*options.aspect_ratio;\n\n  start_drawer(state);\n});\n\n// An explicit resize handler\n// is this like our bounds??? or does this have to do with scales?\n// https://rstudio.github.io/r2d3/articles/advanced_rendering.html\n// redraws plot as you resize your browser window \n// (box has changed size that we did not do on code end)\nr2d3.onResize(function(width, height, options) {\n  state.w = height*state.options.aspect_ratio;\n  state.h = height - margin.top - margin.bottom;\n\n//  start_drawer(state, reset = false);\n\n});\n\n//function calculateDistance(user_line, line_data) {\n//  let totalDistance = 0;\n//  let pt_count = 0;\n//\n//  // Iterate over the points of user_line\n//  for (let i = 0; i < user_line.length; i++) {\n//    const point1 = user_line[i];\n//    const correspondingPoint = line_data.find(point => point.x === point1.x);\n//\n//    if (correspondingPoint && correspondingPoint.y !== null) {\n//      pt_count += 1\n//      // Calculate the distance between the y-values of the two points\n//      const distance = Math.abs(point1.y - correspondingPoint.y);\n//      totalDistance += distance;\n//    }\n//  }\n//  const averageDistance = totalDistance / pt_count;\n//\n//  return averageDistance;\n//}\n\n// JSON.stringify()\n// Main function that draws current state of viz\n// set up scales & draw true line if we decide to do that.\nfunction start_drawer(state, reset = true){\n  const scales = setup_scales(state);\n  \n  if(!state.free_draw){\n    draw_true_line(state, scales, state.draw_start);\n  }\n  \n  // Cover hidden portion with a rectangle\n  // const line_hider = setup_line_hider(state.svg, state.draw_start, scales);\n  \n  // if we reset (these are points that can be drawn) remove what user has drawn.\n  if(reset){\n    // start with the svg object provided by r2d3\n    // multiassign where setup_drawable_points is grabbing the parameters it needs from state: data, freedraw and draw_start\n    state.drawable_points = setup_drawable_points(state);\n  }\n  \n  // if we have points, we draw user's line.\n  draw_user_line(state, scales);\n  draw_rectangle(state, scales);\n  draw_finished_line(state, scales, state.draw_start);\n  \n    // draw points for initial portion\n  if(state.points != \"none\"){\n    draw_points(state, scales);\n  }\n  \n  // invert from pixle to data scale when they draw their points\n  // THIS IS WHERE WE SET A SPECIFIC NUMBER OF POINTS THAT CAN BE DRAWN CORRESPONDING TO 1/2 UNITS ON DATA SCALE...MAKES IT CLUNKY: CONTROLED BY TIBBLE\n  // ISSUES HERE!!!\n  const on_drag = function(){\n    const drag_x = scales.x.invert(d3.event.x);\n    const drag_y = scales.y.invert(d3.event.y);\n    fill_in_closest_point(state, drag_x, drag_y);\n    draw_user_line(state, scales);\n    draw_rectangle(state, scales);\n  };\n  \n  // line_status is set by draw watcher - get user status line\n  // if some points missing - in progress\n  // complete line - done\n  // passes drawn points to shiny when click done\n  // as long as there are dots (missing spaces) it isn't going to pass data back.\n  const on_end = function(){\n    // Check if all points are drawn so we can reveal line\n    const line_status = get_user_line_status(state);\n    \n    if(line_status === 'done'){\n      // User has completed line drawing\n      //if(state.show_finished) line_hider.reveal();\n      //if(!state.free_draw)  line_hider.reveal();\n      if(state.show_finished){\n        draw_finished_line(state, scales, state.draw_start);\n      }\n//      const distance = calculateDistance(svg.select(\"path.user_line\").datum(), state.line_data).toFixed(4);\n//      console.log('Average distance between the drawn line and actual line: '+ distance);\n      \n      \n      // Convert the completedLine to JSON\n      if(typeof Shiny !== 'undefined') {\n        var jsonData = JSON.stringify(svg.select(\"path.user_line\").datum());\n        var newlines = JSON.stringify(newLineData)\n      \n        // Send the data to the Shiny server\n        Shiny.setInputValue(\"completedLineData\", jsonData);\n        Shiny.setInputValue(\"newLineData\", newlines);\n      }\n      \n      // Send the JSON data to R using an HTTP request\n      // var request = new XMLHttpRequest();\n    //  request.open(\"POST\", \"http://localhost:8000\", true);\n  //    request.setRequestHeader(\"Content-Type\", \"application/json\");\n//      request.send(jsonData);\n      \n    }\n  };\n  \n    if(typeof Shiny !== 'undefined') {\n    Shiny.addCustomMessageHandler('resetAction', function(reset) {\n      paths.forEach(function(path) {\n        path.remove();\n      });\n    \n      // Reset paths and lineGens arrays\n      paths = [];\n      lineGens = [];\n      newLineData = [];\n      \n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset);\n    });\n    \n    Shiny.addCustomMessageHandler('newLine', function(drawing){\n      newLine()\n    });\n  }\n\n  // Press button to be able to draw more lines\n  var lineGen, path, data, scale_data = [];\n  var mousedown = false;\n  var isDrawing = false;\n  var draw_watcher = null;\n  var paths = [];\n  var lineGens = [];\n  let newLineData = [];\n  \n  function newLine() {\n    if (isDrawing) {\n      if (scale_data.length > 0) {\n        newLineData.push(scale_data);\n      }\n      // Stop drawing and remove new draw watcher\n      isDrawing = false;\n      if (!state.hide_buttons) {\n      buttonText.text(\"New Line\");\n        buttonRect.transition().duration(200).style(\"fill\", \"#ECECEC\");\n      }\n      draw_watcher.remove();\n  \n      // Reattach the original event handlers\n      svg.select('rect.drag_watcher').call(\n        d3.drag()\n        .on(\"drag\", on_drag)\n        .on(\"end\", on_end)\n      );\n  \n      return;\n    }\n  \n    // Start drawing and create new draw watcher\n    isDrawing = true;\n    if (!state.hide_buttons) {\n      buttonText.text(\"Stop Drawing\");\n      buttonRect.transition().duration(200).style(\"fill\", \"red\");\n    }\n    \n    // Detach the original event handlers\n    svg.select('rect.drag_watcher').on(\".drag\", null);\n  \n    lineGen = d3.line()\n      .x(function (d) { return d.x; })\n      .y(function (d) { return d.y; });\n    \n    // Store the line generator\n    lineGens.push(lineGen);\n  \n    path = state.svg.append('path')\n      .at(conf_int_line_attrs)\n      .attr(\"stroke-dasharray\", \"7, 5\")\n      .attr(\"opacity\", 0.95);\n      \n    // Store the path\n    paths.push(path);\n  \n    data = [];  // clear data for new line\n    \n    scale_data = [];\n  \n  draw_watcher = state.svg.append('rect')\n    .attr('class', 'draw_watcher')\n    .attr('height', scales.y.range()[0])\n    .attr('width', scales.x.range()[1])\n    .attr('fill', 'grey')\n    .attr('fill-opacity', 0)\n    .call(\n      d3.drag()\n      .on(\"start\", function() {\n        mousedown = true;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                          y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"drag\", function() {\n        if (!mousedown) return;\n        var coords = d3.mouse(this);\n        if (!coordsInWatcher(coords)) return;\n        data.push({ x: coords[0], y: coords[1] });\n        scale_data.push({ x: scales.x.invert(coords[0]), \n                  y: scales.y.invert(coords[1]) })\n        path.attr('d', lineGen(data));\n      })\n      .on(\"end\", function() {\n        mousedown = false;\n      })\n    )\n    .on('mouseout', function() {\n      mousedown = false;\n    });\n\n  // Check if mouse is within draw_watcher\n  function coordsInWatcher(coords) {\n    var bounds = draw_watcher.node().getBBox();\n    return coords[0] >= bounds.x && coords[0] <= bounds.x + bounds.width\n      && coords[1] >= bounds.y && coords[1] <= bounds.y + bounds.height;\n  }\n  }\n  \n  if (!state.hide_buttons) {\n    const button = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 75})`)\n      .on(\"click\", newLine);\n    \n    var buttonRect = button.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 80)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n    \n    button.on(\"mouseover\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkgray\");\n      }\n      else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"darkred\");\n      }\n    })\n    .on(\"mouseout\", function() {\n      if (!isDrawing) {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"#ECECEC\");\n      }\n            else {\n        d3.select(this).select(\"rect\")\n          .style(\"fill\", \"red\");\n      }\n    });\n    \n    var buttonText = button.append(\"text\")\n      .attr(\"x\", 40)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"New Line\");\n\n    // add draw line and reset buttons\n        const resetButton = svg.append(\"g\")\n      .attr(\"class\", \"button\")\n      .style(\"cursor\", \"pointer\")\n      .attr(\"transform\", `translate(${state.w + margin.right + margin.left}, ${margin.top + 35})`)\n      .on(\"click\", handleClick)\n    \n    resetButton.append(\"rect\")\n      .attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", 60)\n      .attr(\"height\", 25)\n      .attr(\"rx\", 5)\n      .attr(\"ry\", 5)\n      .style(\"fill\", \"#ECECEC\")\n      .style(\"stroke\", \"black\")\n      .style(\"stroke-width\", 2);\n      \n    resetButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n    \n    resetButton.append(\"text\")\n      .attr(\"x\", 30)\n      .attr(\"y\", 15)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"alignment-baseline\", \"middle\")\n      .attr(\"fill\", \"black\")\n      .attr(\"font-size\", 14)\n      .text(\"Reset\")\n    \n    // Click event handler\n    function handleClick() {\n      // Remove all new lines\n      paths.forEach(function(path) {\n        path.remove();\n      });\n      \n      // Reset paths and lineGens arrays\n      paths = [];\n      newLineData = [];\n      lineGens = [];\n      if (isDrawing) {\n        newLine();\n      }\n      start_drawer(state, reset = true)\n    }\n\n    // add download data buttons\n  const downloadButton = svg.append(\"g\")\n    .attr(\"class\", \"button\")\n    .style(\"cursor\", \"pointer\")\n    .attr(\"transform\", \n      `translate(${state.w + margin.right + margin.left}, ${margin.top})`)\n    .on(\"click\", handleDownloadClick);\n\n  downloadButton.append(\"rect\")\n    .attr(\"x\", 0)\n    .attr(\"y\", 0)\n    .attr(\"width\", 110)\n    .attr(\"height\", 25)\n    .attr(\"rx\", 5)\n    .attr(\"ry\", 5)\n    .style(\"fill\", \"#ECECEC\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-width\", 2)\n    \n  downloadButton.on(\"mouseover\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"darkgray\");\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).select(\"rect\")\n      .style(\"fill\", \"#ECECEC\");\n  });\n  \n  downloadButton.append(\"text\")\n    .attr(\"x\", 55)\n    .attr(\"y\", 12.5)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"alignment-baseline\", \"middle\")\n    .attr(\"fill\", \"black\")\n    .attr(\"font-size\", 14)\n    .text(\"Download Data\");\n  \n  function handleDownloadClick() {\n    var drawn_line = svg.select(\"path.user_line\").datum();\n    var jsonData = JSON.stringify(drawn_line);\n    var new_line_data = JSON.stringify(newLineData);\n    download_content = \"Original Line:\\n\" + jsonData + \"\\n\\nNew Lines:\\n\" + new_line_data;\n    var bb = new Blob([download_content], { type: 'text/plain' });\n    var a = document.createElement('a');\n    a.download = 'draw_line_data.txt';\n    a.href = window.URL.createObjectURL(bb);\n    a.click();\n  }\n  }\n  \n  setup_draw_watcher(state.svg, scales, on_drag, on_end);\n  \n  // Do we have a title?\n    if(state.title){\n      if (state.subtitle) {\n        state.svg.append('text')\n        .at({\n          y: -margin.top/2 - 10,\n          dominantBaseline: 'middle',\n          fontSize: '1.3rem',\n        })\n        .style('font-family', system_font)\n        .text(state.title);\n      }\n      else {\n        state.svg.append('text')\n        .at({\n          y: -margin.top/2,\n          dominantBaseline: 'middle',\n          fontSize: '1.5rem',\n        })\n        .style('font-family', system_font)\n        .text(state.title);\n      }\n    }\n    \n    // Do we have a subtitle?\n    if (state.subtitle){\n      state.svg.append('text')\n      .at({\n        y: -margin.top/2 + 10,\n        dominantBaseline: 'middle',\n        fontSize: '0.8rem',\n      })\n      .style('font-family', system_font)\n      .text(state.subtitle);\n    }\n    \n    // Do we have an x-axis label?\n    if (state.x_lab) {\n      if (state.subtitle) {\n        state.svg.append('text')\n        .at({\n          x: state.w / 2,\n          y: state.h + margin.bottom,\n          fontSize: '0.8rem',\n          textAnchor: 'middle',\n        })\n        .style('font-family', system_font)\n        .text(state.x_lab);\n      }\n      else {\n        state.svg.append('text')\n        .at({\n          x: state.w / 2,\n          y: state.h + margin.bottom,\n          fontSize: '1rem',\n          textAnchor: 'middle',\n        })\n        .style('font-family', system_font)\n        .text(state.x_lab);\n      }\n    }\n    \n    // Do we have a y-axis label?\n    if (state.y_lab) {\n      if (state.subtitle) {\n        state.svg.append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"x\", 0 - (state.h / 2))\n        .attr(\"y\",  -margin.right - 22)\n        .attr(\"font-size\", \"0.8rem\")\n        .attr(\"text-anchor\", \"middle\")\n        .style(\"font-family\", system_font)\n        .text(state.y_lab);\n    }\n      else {\n      state.svg.append(\"text\")\n        .attr(\"transform\", \"rotate(-90)\")\n        .attr(\"x\", 0 - (state.h / 2))\n        .attr(\"y\",  -margin.right - 22)\n        .attr(\"font-size\", \"1rem\")\n        .attr(\"text-anchor\", \"middle\")\n        .style(\"font-family\", system_font)\n        .text(state.y_lab);\n      }\n    }\n}\n\n  function simplify_data({line_data, x_range, threshold_percentage}) {\n    // simplify the drawable_points by binning the points based on a certain threshold_percentage\n    // only allow 3 points per bin (when too many points in a cluster drawing line takes a while and \n    // if a large cluster can sometime be impossible to draw)\n    const bin_size = x_range * threshold_percentage;\n    const simplified_points = [];\n    let current_bin = [];\n  \n    for (let i = 0; i < line_data.length; i++) {\n      current_bin.push(line_data[i]);\n      \n      // if at last point or all points in bin x range have been added \n      if (i === line_data.length - 1 || line_data[i + 1].x - current_bin[0].x > bin_size) {\n        // if there are more than 3 points in bin add the first, middle, and last point to drawable_points\n        if (current_bin.length >= 3) {\n          simplified_points.push(current_bin[0], current_bin[Math.floor(current_bin.length / 2)], current_bin[current_bin.length - 1]);\n          // else add all points in current bin to drawable_points\n        } else {\n          simplified_points.push(...current_bin);\n        }\n        // reset current bin to empty\n        current_bin = [];\n      }\n    }\n    return simplified_points;\n  }\n  \n  function interpolate_x({x_range, threshold_size, simplified_points}) {\n    // Set threshold distance as % of the x-range\n    const threshold_distance = x_range * threshold_size;\n    \n    // interpolate x value (adds drawble_points between extreme x values so the line does not jump)\n    let drawable_points = [];\n\n    for (let i = 0; i < simplified_points.length; i++) {\n      const d = simplified_points[i];\n      drawable_points.push(d);\n\n      // If there is another point after this one and their X-distance is larger than \n      // the threshold value then we need to add interpolated points between them.\n      if (i + 1 < simplified_points.length && Math.abs(simplified_points[i+1].x - d.x) > threshold_distance) {\n\n        const interpolated_x = d3.range(d.x + threshold_distance, simplified_points[i+1].x, threshold_distance);\n\n        interpolated_x.forEach((x,i) => {\n          drawable_points.push({\n            x: x,\n            y: null\n          });\n        })\n        \n       }\n     }\n     //remove the repeated x values from drawable_points\n     return drawable_points\n}\n\n  function setup_drawable_points({line_data, free_draw, draw_start}){\n    if (free_draw) {\n      if (state.x_range && (state.x_range[0] < line_data[0].x)) {\n        line_data.unshift({ x: state.x_range[0], y: null });\n      }\n      if (state.x_range && state.x_range[1] > line_data[line_data.length - 1].x) {\n       line_data.push({ x: state.x_range[1], y: null });\n      }\n      \n      // Get range of x values from first and last point\n      const x_range = line_data[line_data.length - 1].x - line_data[0].x\n      \n      let simplified_points = simplify_data({line_data, x_range, threshold_percentage: 0.05})\n      \n      let drawable_points = interpolate_x({x_range, threshold_size: 0.10, simplified_points})\n      \n      //remove the repeated x values from drawable_points\n      return drawable_points\n                .filter((d, i, arr) => i === 0 || d.x !== arr[i - 1].x)\n                .map((d) => ({ x: d.x, y: null }));;\n    } else {\n      return line_data\n      .filter(d => d.x >= draw_start)    \n      .map((d,i) => ({\n        x: d.x,\n        y: i === 0 ? d.y: null\n      }));\n    }\n  }\n\nfunction get_user_line_status({drawable_points, free_draw}){\n  const num_points = drawable_points.length;\n  const num_filled = d3.sum(drawable_points.map(d => d.y === null ? 0: 1));\n  const num_starting_filled = free_draw ? 0: 1;\n  \n  if(num_filled === num_starting_filled){\n    return 'unstarted';\n  } else if(num_points === num_filled){\n    return 'done';\n  } else {\n    return 'in_progress';\n  }\n}\n\n// Draw visable portion of line\nfunction draw_true_line({svg, line_data, draw_start}, scales){\n  var df = line_data.filter(function(d){ return d.x<=draw_start})\n  state.svg.selectAppend(\"path.shown_line\")\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer);\n}\n\nfunction draw_points({svg, point_data, points_end, points}, scales){\n  \n    if(points == \"partial\"){\n      var df = point_data.filter(function(d){return (d.x<=points_end)});\n    } else {\n      var df = point_data;\n    }\n    \n  const dots = state.svg.selectAll(\"circle\").data(df)\n  \n  dots\n    .enter().append(\"circle\")\n    .merge(dots)\n    .attr(\"cx\", d => scales.x(d.x))\n    .attr(\"cy\", d => scales.y(d.y))\n    .attr(\"r\", 2)\n    .style(\"fill\", \"black\")\n    .style(\"opacity\", 0.8)\n    .style(\"stroke\", \"black\")\n    \n}\n\nif ((state.show_tooltip) || (typeof Shiny !== 'undefined')) {\n  var tooltip = d3.select(\"body\").append(\"div\")\n  .attr(\"class\", \"tooltip\")\n  .style(\"position\", \"absolute\")\n  .style(\"opacity\", 0)\n  .style(\"padding\", \"6px\")\n  .style(\"background-color\", \"#fff\")\n  .style(\"color\", \"#333\")\n  .style(\"border\", \"1px solid #ccc\")\n  .style(\"border-radius\", \"4px\")\n  .style(\"font-size\", \"14px\")\n  .style(\"pointer-events\", \"none\");\n}\n\nif(typeof Shiny !== 'undefined') {\n  // Recieve message from shiny to show or hide tooltip\n  Shiny.addCustomMessageHandler(\"tooltipState\", function(newState) {\n    if (newState) {\n      tooltip = d3.select(\"body\").append(\"div\")\n        .attr(\"class\", \"tooltip\")\n        .style(\"position\", \"absolute\")\n        .style(\"opacity\", 0)\n        .style(\"padding\", \"6px\")\n        .style(\"background-color\", \"#fff\")\n        .style(\"color\", \"#333\")\n        .style(\"border\", \"1px solid #ccc\")\n        .style(\"border-radius\", \"4px\")\n        .style(\"font-size\", \"14px\")\n        .style(\"pointer-events\", \"none\");\n    }\n    else {\n      d3.select(\".tooltip\").remove();\n    }\n  });\n}\n\nfunction draw_rectangle({svg, drawable_points, line_data, draw_start, width, height, free_draw, x_by}, scales){\n    if(get_user_line_status(state) === 'unstarted'){\n      if(free_draw){\n         var xmin = line_data[0].x\n         var len  = line_data.length - 1\n         var xmax = line_data[len].x\n         var drawSpace_start = scales.x(xmin)\n         var drawSpace_end   = scales.x(xmax)\n       } else {\n         var drawSpace_start = scales.x(draw_start)\n         var drawSpace_end   = state.w\n       }\n    } else {\n      if(get_user_line_status(state) === 'done'){\n        var drawSpace_start = scales.x(1000000)\n      } else {\n        var df = drawable_points.filter(function(d){return (d.y === null)});\n        var xmin = df[0].x - x_by\n        var len  = line_data.length - 1\n        var xmax = line_data[len].x\n        var drawSpace_start = scales.x(xmin)\n        var drawSpace_end   = scales.x(xmax)\n      }\n    }\n\n    const draw_region = state.svg.selectAppend(\"rect\");\n    \n    draw_region\n      .attr(\"x\", drawSpace_start)\n      .attr(\"width\",drawSpace_end - drawSpace_start)\n      .attr(\"y\", 0)\n      .attr(\"height\", state.h)\n      //.style(\"fill\", \"#e0f3f3\")\n      .style(\"fill-opacity\", 0.4)\n      .style(\"fill\", \"rgba(255,255,0,.8)\")\n\n    if (typeof tooltip !== 'undefined') {\n      svg.on(\"mousemove\", function(d) {\n      // Get the mouse coordinates relative to the SVG container\n      var [mouseX, mouseY] = d3.mouse(this);\n  \n      // Check if the mouse is within the rectangle's bounds\n      var isMouseOverDrawRegion =\n        mouseX >= drawSpace_start &&\n        mouseX <= drawSpace_end &&\n        mouseY >= 0 &&\n        mouseY <= state.h;\n  \n      if (isMouseOverDrawRegion) {\n        // Calculate the progress based on the width of draw_region relative to the total width\n        var progress = (1 - (drawSpace_end - drawSpace_start) / (drawSpace_end));\n        \n        // Set the progress to a minimum of 0 if it is negative\n        progress = Math.max(progress, 0);\n        \n        // Show tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n        tooltip.html(\"Progress: \" + (progress * 100).toFixed(2) + \"%\")\n          .style(\"left\", (d3.event.pageX + 10) + \"px\")\n          .style(\"top\", (d3.event.pageY - 28) + \"px\");\n      } else {\n        // Hide tooltip\n        tooltip.transition()\n          .duration(200)\n          .style(\"opacity\", 0);\n      }\n    });\n    \n    // Hide tooltip when mouse leaves the SVG container\n    svg.on(\"mouseleave\", function() {\n      tooltip.transition()\n        .duration(200)\n        .style(\"opacity\", 0);\n    });\n    }\n}\n\nfunction draw_user_line(state, scales){\n  const {svg, drawable_points, drawn_line_color} = state;\n  \n  const user_line = state.svg.selectAppend(\"path.user_line\");\n  \n  // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    user_line.remove();\n    return;\n  }\n\n  // Draws the points the user is drawing with their mouse\n  user_line\n      .datum(drawable_points)\n      .at(default_line_attrs)\n      .attr('stroke', drawn_line_color)\n      .attr(\"d\", scales.line_drawer)\n      .style(\"stroke-dasharray\", (\"1, 7\"));\n}\n\nfunction draw_finished_line({svg, line_data, draw_start, free_draw}, scales){\n  \n  \n  if(!free_draw){\n    var df = line_data.filter(function(d){ return d.x >= draw_start})\n    if (state.conf_int) {\n      var lwr = state.lower_bound.filter(function(d){ return d.x >= draw_start})\n      var upr = state.upper_bound.filter(function(d){ return d.x >= draw_start})\n    }\n  } else {\n    var df = line_data\n    if (state.conf_int) {\n      var lwr = state.lower_bound\n      var upr = state.upper_bound\n    }\n  }\n  \n  \n  const finished_line = state.svg.selectAppend(\"path.finished_line\")\n  const lower_bound = state.svg.selectAppend(\"path.lower_bound\")\n  const upper_bound = state.svg.selectAppend(\"path.upper_bound\")\n  \n    // Only draw line if there's something to draw.\n  if(get_user_line_status(state) === 'unstarted'){\n    finished_line.remove();\n    lower_bound.remove();\n    upper_bound.remove();\n    return;\n  }\n  \n  finished_line\n  .datum(df)\n  .at(default_line_attrs)\n  .attr(\"d\", scales.line_drawer)\n  .attr(\"opacity\", 0.5)\n\n  if (state.conf_int) {\n    lower_bound\n    .datum(lwr)\n    .at(conf_int_line_attrs)\n    .attr(\"d\", scales.line_drawer)\n    .attr(\"opacity\", 0.5)\n    \n    upper_bound\n    .datum(upr)\n    .at(conf_int_line_attrs)\n    .attr(\"d\", scales.line_drawer)\n    .attr(\"opacity\", 0.5)\n  }\n  \n}\n\n// from state we need drawable_points - from setup_drawable_points() function that modifies state (get all x points bigger than or equal to draw_start and set up with a null), pin_start, and free_draw parameters\n// drag_x, drag_y come from on_drag() function\nfunction fill_in_closest_point({drawable_points, pin_start, free_draw}, drag_x, drag_y){\n  // find closest point on data to draw\n  let last_dist = Infinity;\n  let current_dist;\n  // If nothing triggers break statement than closest point is last point\n  let closest_index = drawable_points.length - 1;\n  const starting_index = free_draw ? 0 : (pin_start ? 1: 0);\n  // for loop to check where closest point to where I am\n  for(i = starting_index; i < drawable_points.length; i++){\n    current_dist = Math.abs(drawable_points[i].x - drag_x);\n    // If distances start going up we've passed the closest point\n    if(last_dist - current_dist < 0) {\n      closest_index = i - 1;\n      break;\n    }\n    last_dist = current_dist;\n  }\n  \n  drawable_points[closest_index].y = drag_y;\n}\n\n\nfunction setup_draw_watcher(svg, scales, on_drag, on_end){\n  \n  // could have called drag_watcher whatever we wanted\n  // .at is space it begins watching\n  // .call is \"do something\" d3.drag() is the mouse action puts listeners to react to user input.\n  svg.selectAppend('rect.drag_watcher')\n  .at({\n    height: scales.y.range()[0],\n    width: scales.x.range()[1],\n    fill: 'grey',\n    fillOpacity: 0,\n  })\n  .call(\n    d3.drag()\n    .on(\"drag\", on_drag)\n    .on(\"end\", on_end)\n  );\n}\n\n// Setup scales for visualization\nfunction setup_scales(state){\n  // multi-assign: x_range, etc. coming from options\n  const {w, h, line_data, x_range, y_range, x_name, y_name, linear} = state;\n  \n  // convert x from data scale to pixle scale\n  const x = d3.scaleLinear()\n  .domain(x_range || d3.extent(line_data, d => d.x))\n  .range([0, w]);\n  \n  //console.log(linear);\n  if (linear == 'true') {\n    //console.log('in linear block');\n    // converts from data linear scale to pixle scale\n    var y = d3.scaleLinear()\n    .domain(y_range || d3.extent(line_data, d => d.y))\n    .range([h, 0]);\n  } else {\n    //console.log('in log block');\n    // converts from data log scale to pixle scale\n    if (state.log_base == null) {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(Math.E);\n    }\n    else {\n      var y = d3.scaleLog()\n      .domain(y_range || d3.extent(line_data, d => d.y))\n      .range([h, 0]).base(state.log_base);\n    }\n  }\n  \n  const xAxis = d3.axisBottom().scale(x).tickSizeOuter(0);\n  const yAxis = d3.axisLeft().scale(y).tickFormat(d3.format(\".4\")).tickSizeOuter(0);\n  const xAxisGrid = d3.axisBottom().scale(x).tickSize(-h).tickFormat('');\n  const yAxisGrid = d3.axisLeft().scale(y).tickSize(-w).tickFormat('');\n  \n  // Remove all grid related things first\n  // remove everything when you convert from linear and log and vise versa.\n  // want html element <g> that has class axis-grid\n  state.svg.selectAll(\"g.x_grid\").remove()\n  state.svg.selectAll(\"g.y_grid\").remove()\n  // could call axis-grid \"fred\"\n  state.svg.selectAll(\"g.axis-grid\").remove()\n  \n  state.svg.selectAll(\"path.shown_line\").remove()\n  state.svg.selectAll(\"circle\").remove()\n  \n  state.svg.selectAppend(\"g.x_grid\")\n  .attr('class', 'x axis-grid')\n  .translate([0,h])\n  .call(xAxisGrid);\n  \n  state.svg.selectAppend(\"g.y_grid\")\n  .attr('class', 'y axis-grid')\n  .call(yAxisGrid);\n  \n  state.svg.selectAll(\".axis-grid .tick\")\n  .style(\"stroke\", \"light-grey\")\n  .style(\"opacity\", \".3\");\n  \n  state.svg.selectAppend(\"g.x_axis\")\n  .translate([0,h])\n  .call(xAxis);\n  \n  state.svg.selectAppend(\"g.y_axis\")\n  .call(yAxis);\n  \n  const line_drawer = d3.line()\n  .defined(d => d.y !== null)\n  .x(d => x(d.x))\n  .y(d => y(d.y));\n  \n  return {\n    x,\n    y,\n    line_drawer,\n  };\n}\n};","style":[],"version":5,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script><p>In the plot above, the dashed lines that are displayed upon
completion of the original line (shown by the yellow progress region)
represent the lower and upper bounds of the 95% confidence interval for
the line of best fit. The user can attempt to draw the upper and lower
bounds of the confidence interval using the “New Line” button in the
interactive plot. Try it for yourself in the plot above.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Emily A. Robinson.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
